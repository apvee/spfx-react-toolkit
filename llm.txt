# SPFx React Toolkit - LLM Reference Guide

> **Version**: 0.0.1  
> **SPFx Compatibility**: 1.21.1+  
> **React Version**: 17.x  
> **License**: MIT  
> **Purpose**: Comprehensive reference for AI/LLM code generation

---

## Table of Contents

1. [Quick Reference](#quick-reference)
2. [Core Concepts](#core-concepts)
3. [Setup Pattern](#setup-pattern)
4. [Hook Catalog](#hook-catalog)
5. [Type Definitions](#type-definitions)
6. [Common Patterns](#common-patterns)
7. [Anti-Patterns (DO NOT USE)](#anti-patterns-do-not-use)
8. [Complete Examples](#complete-examples)
9. [Migration Guide](#migration-guide)
10. [Troubleshooting](#troubleshooting)

---

## Quick Reference

### Installation

```bash
# Single command (auto-installs peer dependencies)
npm install @apvee/spfx-react-toolkit
```

**Auto-installed peer dependencies (npm 7+):**
- `jotai` ^2.0.0 - Atomic state management (~3KB, always used)
- `@pnp/sp` ^4.0.0 - SharePoint API (tree-shaken if not used)
- `@pnp/core` ^4.0.0
- `@pnp/queryable` ^4.0.0

### Essential Imports

```typescript
// Provider (required at root)
import { SPFxProvider } from '@apvee/spfx-react-toolkit';

// Common hooks
import {
  useSPFxProperties,
  useSPFxDisplayMode,
  useSPFxThemeInfo,
  useSPFxUserInfo,
  useSPFxSiteInfo,
  useSPFxPageContext,
} from '@apvee/spfx-react-toolkit';



// Types (always use 'type' import)
import type {
  SPFxPropertiesInfo,
  SPFxDisplayModeInfo,
  SPFxUserInfo,
} from '@apvee/spfx-react-toolkit';
```

### Minimal WebPart Setup

```typescript
// In WebPart's render() method
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { SPFxProvider } from '@apvee/spfx-react-toolkit';
import MyComponent from './components/MyComponent';

public render(): void {
  const element = React.createElement(
    SPFxProvider,
    { instance: this as never }, // Cast required for protected properties
    React.createElement(MyComponent)
  );
  
  ReactDom.render(element, this.domElement);
}
```

---

## Core Concepts

### 1. Architecture Overview

**SPFx React Toolkit** provides:
- Single `SPFxProvider` wrapper for entire component tree
- 26+ hooks for accessing SPFx context, properties, services
- Jotai-based atomic state management (per-instance scoped)
- Automatic bidirectional property synchronization
- Type-safe API with full TypeScript support

### 2. State Management

**Jotai Atoms**:
- Each SPFx instance has isolated state via `atomFamily(instanceId)`
- No global store - state is scoped per WebPart/Extension instance
- Automatic cleanup on unmount

**React Context**:
- Static metadata only (instanceId, kind, spfxContext)
- No reactive state in context (prevents unnecessary re-renders)

### 3. Provider Detection

The provider automatically detects:
- `WebPart` - BaseClientSideWebPart
- `AppCustomizer` - BaseApplicationCustomizer
- `CommandSet` - BaseListViewCommandSet
- `FieldCustomizer` - BaseFieldCustomizer

### 4. Instance Isolation

Multiple instances of the same WebPart on a page are isolated:
- Separate state atoms per instance
- Storage keys include instanceId
- No cross-instance pollution

---

## Setup Pattern

### WebPart Integration

```typescript
// MyWebPart.ts
import { Version } from '@microsoft/sp-core-library';
import {
  BaseClientSideWebPart,
  IPropertyPaneConfiguration,
} from '@microsoft/sp-webpart-base';
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { SPFxProvider } from '@apvee/spfx-react-toolkit';
import MyComponent from './components/MyComponent';

export interface IMyWebPartProps {
  title: string;
  description: string;
}

export default class MyWebPart extends BaseClientSideWebPart<IMyWebPartProps> {
  
  public render(): void {
    const element: React.ReactElement = React.createElement(
      SPFxProvider,
      { instance: this as never },
      React.createElement(MyComponent)
    );
    
    ReactDom.render(element, this.domElement);
  }

  protected onDispose(): void {
    ReactDom.unmountComponentAtNode(this.domElement);
  }

  protected get dataVersion(): Version {
    return Version.parse('1.0');
  }

  protected getPropertyPaneConfiguration(): IPropertyPaneConfiguration {
    return {
      pages: [
        {
          header: { description: 'Settings' },
          groups: [
            {
              groupName: 'Basic Settings',
              groupFields: [
                PropertyPaneTextField('title', {
                  label: 'Title'
                }),
                PropertyPaneTextField('description', {
                  label: 'Description'
                })
              ]
            }
          ]
        }
      ]
    };
  }
}
```

### Component Usage

```typescript
// MyComponent.tsx
import * as React from 'react';
import { useSPFxProperties, useSPFxDisplayMode } from '@apvee/spfx-react-toolkit';
import type { IMyWebPartProps } from '../MyWebPart';

const MyComponent: React.FC = () => {
  const { properties, setProperties } = useSPFxProperties<IMyWebPartProps>();
  const { isEdit } = useSPFxDisplayMode();
  
  return (
    <div>
      <h1>{properties?.title ?? 'Default Title'}</h1>
      <p>{properties?.description}</p>
      {isEdit && (
        <button onClick={() => setProperties({ title: 'Updated!' })}>
          Update Title
        </button>
      )}
    </div>
  );
};

export default MyComponent;
```

---

## Provider Components

The toolkit provides **4 type-safe Provider components**, one for each SPFx component type. Each Provider automatically detects the component kind, initializes instance-scoped state, and enables all hooks.

### `SPFxWebPartProvider<TProps>`

**Type:** Provider Component for WebParts  
**Description:** Type-safe context provider specifically for WebParts. This is a wrapper around the base provider that accepts a `BaseClientSideWebPart` instance directly without requiring type casting. Use this provider in WebParts instead of the generic `SPFxProvider`.

**Type Parameters:**
- `TProps extends {}` - The properties type for the WebPart (defaults to `{}`)

**Props:** `SPFxWebPartProviderProps<TProps>`
- `instance: BaseClientSideWebPart<TProps>` - The SPFx WebPart instance (required)
- `children?: React.ReactNode` - The children to render within the provider (optional)

**Returns:** `JSX.Element`

**Key Features:**
- ✅ Type-safe props inference from WebPart
- ✅ No type casting required (`instance: this` works directly)
- ✅ Automatic Property Pane synchronization (bidirectional)
- ✅ Full access to all 35+ hooks within child components
- ✅ Instance-scoped state isolation (multi-instance support on same page)
- ✅ Display mode detection (Edit/Read)
- ✅ Container size tracking for responsive layouts

**Use Cases:**
- Modern SharePoint WebParts (primary use case)
- Data visualization components (charts, graphs, dashboards)
- Forms and input controls with Property Pane integration
- Dashboard widgets with real-time data
- Content aggregators (news, documents, lists)
- Interactive reports and analytics
- Custom property-driven experiences
- Multi-instance components (e.g., multiple identical WebParts on same page)

**Example:**
```typescript
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { BaseClientSideWebPart } from '@microsoft/sp-webpart-base';
import { SPFxWebPartProvider, useSPFxProperties, useSPFxDisplayMode, useSPFxThemeInfo } from '@apvee/spfx-react-toolkit';

export interface IMyWebPartProps {
  title: string;
  description: string;
}

export default class MyWebPart extends BaseClientSideWebPart<IMyWebPartProps> {
  public render(): void {
    ReactDom.render(
      <SPFxWebPartProvider instance={this}>
        <MyComponent />
      </SPFxWebPartProvider>,
      this.domElement
    );
  }
}

const MyComponent: React.FC = () => {
  const { properties, setProperties } = useSPFxProperties<IMyWebPartProps>();
  const { isEdit } = useSPFxDisplayMode();
  const theme = useSPFxThemeInfo();

  return (
    <div style={{ padding: '20px', backgroundColor: theme?.palette.white }}>
      <h1>{properties?.title || 'Default Title'}</h1>
      <p>{properties?.description}</p>
      {isEdit && (
        <button onClick={() => setProperties({ title: 'Updated' })}>
          Update Title
        </button>
      )}
    </div>
  );
};
```

**Best Practices:**
- ✅ Always implement `onDispose()` to unmount React components
- ✅ Use `getPropertyPaneConfiguration()` for WebPart settings
- ✅ Leverage hooks for clean, declarative code
- ✅ Use `setProperties()` for automatic Property Pane sync
- ✅ Test with multiple instances on the same page
- ✅ Implement responsive design using `useSPFxContainerSize()`
- ✅ Handle Edit/Read modes with `useSPFxDisplayMode()`
- ✅ Use theme tokens from `useSPFxThemeInfo()` for consistent styling
- ✅ Store per-instance data with `useSPFxLocalStorage()` or `useSPFxSessionStorage()`
- ❌ Don't access `this.context` directly in components (use hooks)
- ❌ Don't create global state that affects multiple instances
- ❌ Don't forget to handle loading states for async operations
- ❌ Don't perform heavy operations in render (use `useEffect` or `useMemo`)

---

### `SPFxApplicationCustomizerProvider<TProps>`

**Type:** Provider Component for Application Customizers  
**Description:** Type-safe context provider specifically for Application Customizers. This is a wrapper around the base provider that accepts a `BaseApplicationCustomizer` instance directly without requiring type casting. Use this provider in Application Customizers instead of the generic `SPFxProvider`.

**Type Parameters:**
- `TProps extends {}` - The properties type for the Application Customizer (defaults to `{}`)

**Props:** `SPFxApplicationCustomizerProviderProps<TProps>`
- `instance: BaseApplicationCustomizer<TProps>` - The SPFx Application Customizer instance (required)
- `children?: React.ReactNode` - The children to render within the provider (optional)

**Returns:** `JSX.Element`

**Key Features:**
- ✅ Type-safe props inference from Application Customizer
- ✅ No type casting required (`instance: this` works directly)
- ✅ Automatic placeholder management
- ✅ Full access to all 35+ hooks within child components
- ✅ Instance-scoped state isolation (multiple placeholders supported)

**Supported Placeholders:**
- `PlaceholderName.Top` - Header area (above page title)
- `PlaceholderName.Bottom` - Footer area (below page content)

**Example:**
```typescript
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { BaseApplicationCustomizer, PlaceholderName } from '@microsoft/sp-application-base';
import { SPFxApplicationCustomizerProvider, useSPFxProperties, useSPFxThemeInfo } from '@apvee/spfx-react-toolkit';

export interface IMyCustomizerProps {
  message?: string;
  backgroundColor?: string;
}

export default class MyApplicationCustomizer extends BaseApplicationCustomizer<IMyCustomizerProps> {
  public onInit(): Promise<void> {
    const topPlaceholder = this.context.placeholderProvider.tryCreateContent(PlaceholderName.Top);

    if (topPlaceholder) {
      ReactDom.render(
        <SPFxApplicationCustomizerProvider instance={this}>
          <MyHeaderComponent />
        </SPFxApplicationCustomizerProvider>,
        topPlaceholder.domElement
      );
    }

    return Promise.resolve();
  }
}

const MyHeaderComponent: React.FC = () => {
  const { properties } = useSPFxProperties<IMyCustomizerProps>();
  const theme = useSPFxThemeInfo();

  return (
    <div style={{ 
      backgroundColor: properties?.backgroundColor || theme?.palette.themePrimary,
      padding: '10px',
      color: theme?.palette.white
    }}>
      {properties?.message || 'Custom Header'}
    </div>
  );
};
```

**Best Practices:**
- ✅ Always check if placeholder exists before rendering (`if (placeholder)`)
- ✅ Use `onDispose()` to clean up resources and unmount React components
- ✅ Keep customizers lightweight - avoid heavy computations in render
- ✅ Use hooks (`useSPFxProperties`, `useSPFxThemeInfo`) for dynamic styling
- ✅ Test in both modern and classic SharePoint pages
- ❌ Don't modify DOM outside React (let React manage the placeholder)
- ❌ Don't create global state - use instance-scoped hooks

---

### `SPFxFieldCustomizerProvider<TProps>`

**Type:** Provider Component for Field Customizers  
**Description:** Type-safe context provider specifically for Field Customizers. This is a wrapper around the base provider that accepts a `BaseFieldCustomizer` instance directly without requiring type casting. Use this provider in Field Customizers instead of the generic `SPFxProvider`.

**Type Parameters:**
- `TProps extends {}` - The properties type for the Field Customizer (defaults to `{}`)

**Props:** `SPFxFieldCustomizerProviderProps<TProps>`
- `instance: BaseFieldCustomizer<TProps>` - The SPFx Field Customizer instance (required)
- `children?: React.ReactNode` - The children to render within the provider (optional)

**Returns:** `JSX.Element`

**Key Features:**
- ✅ Type-safe props inference from Field Customizer
- ✅ No type casting required (`instance: this` works directly)
- ✅ Cell-level rendering with full SPFx context
- ✅ Full access to all 35+ hooks within child components
- ✅ Instance-scoped state isolation per field
- ✅ Access to field value and list item data

**Use Cases:**
- Custom field rendering (text, numbers, dates, booleans, choice fields, etc.)
- Conditional formatting based on field values or business rules
- Interactive field controls (clickable links, action buttons, status badges)
- Real-time data visualization in list views (progress bars, charts, icons)
- Field-specific permissions or security trimming
- Multi-field aggregation and calculations

**Example:**
```typescript
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { BaseFieldCustomizer, IFieldCustomizerCellEventParameters } from '@microsoft/sp-listview-extensibility';
import { SPFxFieldCustomizerProvider, useSPFxProperties, useSPFxThemeInfo } from '@apvee/spfx-react-toolkit';

export interface IMyFieldCustomizerProps {
  highlightThreshold?: number;
}

export default class MyFieldCustomizer extends BaseFieldCustomizer<IMyFieldCustomizerProps> {
  public onRenderCell(event: IFieldCustomizerCellEventParameters): void {
    ReactDom.render(
      <SPFxFieldCustomizerProvider instance={this}>
        <MyFieldRenderer value={event.fieldValue} />
      </SPFxFieldCustomizerProvider>,
      event.domElement
    );
  }

  public onDisposeCell(event: IFieldCustomizerCellEventParameters): void {
    ReactDom.unmountComponentAtNode(event.domElement);
    super.onDisposeCell(event);
  }
}

const MyFieldRenderer: React.FC<{ value: any }> = ({ value }) => {
  const { properties } = useSPFxProperties<IMyFieldCustomizerProps>();
  const theme = useSPFxThemeInfo();
  
  const threshold = properties?.highlightThreshold ?? 100;
  const isHighlighted = typeof value === 'number' && value > threshold;

  return (
    <div style={{
      backgroundColor: isHighlighted ? theme?.palette.red : 'transparent',
      color: isHighlighted ? theme?.palette.white : theme?.palette.neutralPrimary,
      padding: '4px 8px'
    }}>
      {value} {isHighlighted && '⚠️'}
    </div>
  );
};
```

**Best Practices:**
- ✅ Always implement `onDisposeCell` to unmount React components
- ✅ Keep field renderers lightweight - they render for every cell
- ✅ Use memoization (`React.memo`, `useMemo`) for performance
- ✅ Pass only necessary data as props to child components
- ✅ Use hooks (`useSPFxThemeInfo`) for consistent styling
- ✅ Test with large lists (100+ items) to verify performance
- ✅ Handle null/undefined field values gracefully
- ❌ Don't perform heavy computations in render (move to `useMemo`)
- ❌ Don't make API calls in render (use `useEffect` with proper dependencies)
- ❌ Don't create event handlers without `useCallback` (causes re-renders)
- ❌ Don't access `this.context` directly (use hooks instead)

---

### `SPFxListViewCommandSetProvider<TProps>`

**Type:** Provider Component for ListView Command Sets  
**Description:** Type-safe context provider specifically for ListView Command Sets. This is a wrapper around the base provider that accepts a `BaseListViewCommandSet` instance directly without requiring type casting. Use this provider in ListView Command Sets instead of the generic `SPFxProvider`.

**Type Parameters:**
- `TProps extends {}` - The properties type for the ListView Command Set (defaults to `{}`)

**Props:** `SPFxListViewCommandSetProviderProps<TProps>`
- `instance: BaseListViewCommandSet<TProps>` - The SPFx ListView Command Set instance (required)
- `children?: React.ReactNode` - The children to render within the provider (optional)

**Returns:** `JSX.Element`

**Key Features:**
- ✅ Type-safe props inference from ListView Command Set
- ✅ No type casting required (`instance: this` works directly)
- ✅ Access to selected items and list context
- ✅ Full access to all 35+ hooks within child components
- ✅ Instance-scoped state isolation per command
- ✅ Dialog and panel rendering support

**Use Cases:**
- Custom bulk actions on selected list items
- Confirmation dialogs with full SPFx context access
- Side panels for item editing, details view, or forms
- Export/import operations with selected rows (CSV, Excel, PDF)
- Workflow triggers and batch approvals from list view
- Multi-item batch processing (update, delete, copy, move)
- Custom integrations with external systems (webhook triggers, API calls)

**Example:**
```typescript
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { BaseListViewCommandSet, IListViewCommandSetExecuteEventParameters } from '@microsoft/sp-listview-extensibility';
import { SPFxListViewCommandSetProvider, useSPFxProperties, useSPFxThemeInfo } from '@apvee/spfx-react-toolkit';

export interface IMyCommandSetProps {
  confirmationRequired?: boolean;
  successMessage?: string;
}

export default class MyCommandSet extends BaseListViewCommandSet<IMyCommandSetProps> {
  public onExecute(event: IListViewCommandSetExecuteEventParameters): void {
    const dialogElement = document.createElement('div');
    document.body.appendChild(dialogElement);

    ReactDom.render(
      <SPFxListViewCommandSetProvider instance={this}>
        <MyDialogComponent 
          items={event.selectedRows} 
          onDismiss={() => {
            ReactDom.unmountComponentAtNode(dialogElement);
            document.body.removeChild(dialogElement);
          }}
        />
      </SPFxListViewCommandSetProvider>,
      dialogElement
    );
  }
}

interface IMyDialogProps {
  items: any[];
  onDismiss: () => void;
}

const MyDialogComponent: React.FC<IMyDialogProps> = ({ items, onDismiss }) => {
  const { properties } = useSPFxProperties<IMyCommandSetProps>();
  const theme = useSPFxThemeInfo();

  const handleAction = () => {
    if (properties?.confirmationRequired && !confirm('Are you sure?')) return;
    alert(properties?.successMessage || 'Action completed!');
    onDismiss();
  };

  return (
    <div style={{ padding: '24px', backgroundColor: theme?.palette.white }}>
      <h2 style={{ color: theme?.palette.themePrimary }}>
        Process {items.length} item{items.length !== 1 ? 's' : ''}
      </h2>
      <button onClick={handleAction}>Execute</button>
      <button onClick={onDismiss}>Cancel</button>
    </div>
  );
};
```

**Best Practices:**
- ✅ Always clean up DOM elements in `onDismiss` callback
- ✅ Use `onExecute` event parameters to access selected rows
- ✅ Implement loading states for async operations
- ✅ Show confirmation dialogs for destructive actions
- ✅ Handle errors gracefully with user-friendly messages
- ✅ Use hooks (`useSPFxSPHttpClient`) for API calls
- ✅ Test with single and multiple item selections
- ✅ Consider performance with large selections (100+ items)
- ❌ Don't perform long-running operations synchronously
- ❌ Don't forget to unmount React components on dismiss
- ❌ Don't access `this.context` directly (use hooks instead)
- ❌ Don't create memory leaks with unremoved DOM elements

---

## Hook Catalog

### Core & Properties

#### `useSPFxContext()`
**Purpose**: Access raw SPFx context metadata (⚠️ Advanced/Internal Hook)  
**Returns**: `SPFxContextValue`  
**Use Case**: Advanced scenarios, custom integrations, building custom hooks

**⚠️ Warning**: This is a low-level hook. Most users should use higher-level hooks instead:
- Use `useSPFxPageContext()` for PageContext access
- Use `useSPFxInstanceInfo()` for instance ID and kind
- Use specific hooks for common scenarios

**Return Type:**
```typescript
interface SPFxContextValue {
  instanceId: string;      // Unique identifier for this SPFx instance
  spfxContext: any;        // Raw SPFx context (WebPartContext, ApplicationCustomizerContext, etc.)
  kind: HostKind;          // 'WebPart' | 'AppCustomizer' | 'FieldCustomizer' | 'CommandSet' | 'ACE'
}
```

**Description:**  
Internal hook that provides access to the raw SPFx context metadata. Contains only static reference data:
- instanceId: Unique identifier for this SPFx instance
- spfxContext: The SPFx context object (WebPartContext, etc.)
- kind: Type of host component

This context does NOT contain reactive state. State is managed via Jotai atoms in isolated stores per Provider instance.

**Throws:** `Error` if used outside SPFxProvider

**Example:**
```typescript
import { useSPFxContext } from '@apvee/spfx-react-toolkit';
import type { WebPartContext } from '@microsoft/sp-webpart-base';
import { useMemo } from 'react';

// Building a custom hook on top of the toolkit
function useCustomWebPartInfo() {
  const { spfxContext, kind, instanceId } = useSPFxContext();
  
  return useMemo(() => {
    // Type-safe access based on component kind
    if (kind !== 'WebPart') {
      return null;
    }
    
    const webPartContext = spfxContext as WebPartContext;
    return {
      instanceId,
      displayMode: webPartContext.displayMode,
      domElement: webPartContext.domElement,
      width: webPartContext.domElement?.clientWidth,
      height: webPartContext.domElement?.clientHeight,
    };
  }, [spfxContext, kind, instanceId]);
}

// Usage in component
function AdvancedComponent() {
  const webPartInfo = useCustomWebPartInfo();
  
  if (!webPartInfo) {
    return <div>Not a WebPart context</div>;
  }
  
  return (
    <div>
      <p>Instance: {webPartInfo.instanceId}</p>
      <p>Size: {webPartInfo.width}x{webPartInfo.height}</p>
      <p>Mode: {webPartInfo.displayMode}</p>
    </div>
  );
}
```

**Best Practices:**
- ✅ Use higher-level hooks (`useSPFxPageContext`, `useSPFxInstanceInfo`) when possible
- ✅ Only use for advanced scenarios requiring raw context access
- ✅ Type-cast `spfxContext` based on `kind` for type safety
- ✅ Use for building custom hooks on top of the toolkit
- ✅ Wrap in useMemo/useCallback if doing expensive computations
- ❌ Don't use as first choice - prefer specific hooks
- ❌ Don't access reactive state via this hook (use specific hooks)
- ❌ Don't use outside SPFxProvider (will throw error)

---

#### `useSPFxProperties<T>()`
**Purpose**: Access and update SPFx properties with type safety  
**Returns**: `{ properties: T | undefined, setProperties, updateProperties }`  
**Use Case**: Property Pane synchronization, component configuration

```typescript
const { properties, setProperties, updateProperties } = useSPFxProperties<IMyProps>();

// Direct set (partial merge)
setProperties({ title: 'New Title' });

// Updater function
updateProperties(prev => ({ ...prev, count: (prev?.count ?? 0) + 1 }));
```

#### `useSPFxDisplayMode()`
**Purpose**: Detect edit vs. read mode  
**Returns**: `SPFxDisplayModeInfo`  
**Use Case**: Conditional rendering, edit-only controls, placeholder states, adaptive layouts

**Description:**  
Provides current display mode information for SPFx WebParts and Extensions. Display mode controls whether the component is in Read mode (normal viewing) or Edit mode (editing/configuration). This is a readonly value controlled by SharePoint - it changes when the user clicks the Edit button on the page.

**Return Type:**
```typescript
interface SPFxDisplayModeInfo {
  readonly mode: DisplayMode;    // DisplayMode.Read or DisplayMode.Edit
  readonly isEdit: boolean;      // True if in Edit mode
  readonly isRead: boolean;      // True if in Read mode
}
```

**Key Features:**
- Readonly value controlled by SharePoint (cannot be modified)
- Automatically updates when page mode changes
- Boolean helpers (`isEdit`, `isRead`) for cleaner conditional logic
- Works with all SPFx component types (WebPart, AppCustomizer, etc.)
- Includes shortcut hook `useSPFxIsEdit()` for convenience

**Example - Edit-only controls:**
```typescript
function EditableComponent() {
  const { isEdit } = useSPFxDisplayMode();
  const [title, setTitle] = useState('My Title');
  
  return (
    <Stack tokens={{ childrenGap: 8 }}>
      {isEdit ? (
        <TextField 
          label="Title" 
          value={title} 
          onChange={(_, val) => setTitle(val || '')} 
        />
      ) : (
        <Text variant="xxLarge">{title}</Text>
      )}
      
      {isEdit && (
        <Stack horizontal tokens={{ childrenGap: 8 }}>
          <PrimaryButton text="Save" onClick={handleSave} />
          <DefaultButton text="Cancel" onClick={handleCancel} />
        </Stack>
      )}
    </Stack>
  );
}
```

**Best Practices:**
- ✅ Use `isEdit`/`isRead` booleans for cleaner conditional logic
- ✅ Show helpful placeholders in edit mode when not configured
- ✅ Use edit mode to expose configuration UI and edit controls
- ✅ Hide edit controls in read mode for cleaner, distraction-free UI
- ✅ Consider different layouts for edit vs read for better UX
- ✅ Use `useSPFxIsEdit()` shortcut when only checking edit mode
- ✅ Combine with permissions for secure edit controls
- ✅ Display informative messages in edit mode to guide users
- ❌ Don't try to modify display mode (it's readonly and controlled by SharePoint)
- ❌ Don't assume mode persists across page reloads (check on each render)
- ❌ Don't rely on display mode for security (always check permissions)
- ❌ Don't show edit controls to users without edit permissions

#### `useSPFxInstanceInfo()`
**Purpose**: Access instance metadata (unique ID and component type)  
**Returns**: `SPFxInstanceInfo`  
**Use Case**: Logging, telemetry, debugging, conditional logic, scoped storage, multi-instance scenarios

**Description:**  
Provides essential metadata about the current SPFx component instance. Each SPFx component has a unique instance ID (GUID) that persists across renders and page loads. The `kind` property identifies the component type, enabling conditional logic based on hosting environment.

**Return Type:**
```typescript
interface SPFxInstanceInfo {
  readonly id: string;        // Unique instance ID (GUID, persists across renders)
  readonly kind: HostKind;    // Component type
}

type HostKind = 'WebPart' | 'AppCustomizer' | 'FieldCustomizer' | 'CommandSet' | 'ACE';
```

**Key Features:**
- Unique instance ID that persists across renders and page navigation
- Component type detection for conditional logic
- Essential for logging, telemetry, and debugging
- Used internally by toolkit for scoped storage keys
- Enables multi-instance scenarios (multiple WebParts of same type on page)
- Direct access to context metadata without overhead

**HostKind Values:**
- `'WebPart'` - SharePoint WebPart on modern pages
- `'AppCustomizer'` - Application Customizer (header/footer extensions)
- `'FieldCustomizer'` - Field Customizer (custom field rendering in list views)
- `'CommandSet'` - ListView Command Set (custom list actions and context menus)
- `'ACE'` - Adaptive Card Extension (Viva Connections dashboard cards)

**Use Cases:**
- **Logging & Telemetry**: Track component usage and errors with instance context
- **Conditional Logic**: Different behavior based on component type
- **Scoped Storage**: Create instance-specific localStorage/sessionStorage keys
- **Debug Information**: Display instance metadata for troubleshooting
- **Analytics**: Track individual component instances separately
- **Multi-Instance**: Identify which instance triggered an event
- **Error Reporting**: Include instance ID in error reports for support

**Example - Logging with instance context:**
```typescript
import { useSPFxInstanceInfo } from '@apvee/spfx-react-toolkit';

function MyComponent() {
  const { id, kind } = useSPFxInstanceInfo();
  
  useEffect(() => {
    // Log component initialization with instance context
    console.log(`[${kind}] Instance ${id} initialized`);
    
    // Send telemetry
    if (typeof window !== 'undefined' && (window as any).appInsights) {
      (window as any).appInsights.trackEvent({
        name: 'ComponentInitialized',
        properties: {
          instanceId: id,
          componentKind: kind,
          timestamp: new Date().toISOString()
        }
      });
    }
    
    return () => {
      console.log(`[${kind}] Instance ${id} unmounted`);
    };
  }, [id, kind]);
  
  // Conditional rendering based on component type
  if (kind === 'WebPart') {
    return (
      <div data-instance-id={id}>
        <h3>WebPart View</h3>
        <p>Instance: {id}</p>
      </div>
    );
  }
  
  if (kind === 'AppCustomizer') {
    return (
      <div data-instance-id={id}>
        <span>Extension: {id.substring(0, 8)}</span>
      </div>
    );
  }
  
  return <div>Unsupported component type: {kind}</div>;
}
```

**Best Practices:**
- ✅ Use `id` for logging, telemetry, and analytics
- ✅ Use `kind` for conditional logic based on component type
- ✅ Include instance ID in error logs for easier debugging
- ✅ Use instance ID for scoped storage keys (e.g., `localStorage[id]`)
- ✅ Add `data-instance-id` attribute to root element for debugging
- ✅ Log instance lifecycle events (mount/unmount) with instance ID
- ✅ Use instance ID when reporting issues to support teams
- ✅ Combine with `useSPFxCorrelationInfo()` for comprehensive diagnostics
- ❌ Don't use instance ID for business logic (it's for metadata only)
- ❌ Don't assume instance ID format or length (treat as opaque string)
- ❌ Don't use `kind` as the only security check (always verify permissions)
- ❌ Don't hardcode `kind` values (use type checking or constants)
- ❌ Don't expose instance ID to end users (it's for internal use)

### Context & Environment

#### `useSPFxPageContext()`
**Purpose**: Access full SharePoint PageContext object  
**Returns**: `PageContext`  
**Use Case**: Site info, web info, user info, list context, Teams detection, locale settings, breadcrumbs, logging

**Description:**  
Provides access to SharePoint PageContext from SPFx ServiceScope using dependency injection. The service is consumed lazily and cached. PageContext contains comprehensive information about the current SharePoint context including site collection, web, user, list (if applicable), Teams context, culture/locale settings, and permissions.

**Return Type:**  
`PageContext` - Native SPFx PageContext object

**Key Properties:**
```typescript
pageContext.web.title                    // Web title
pageContext.web.absoluteUrl              // Web absolute URL
pageContext.web.serverRelativeUrl        // Web server-relative URL
pageContext.web.id                       // Web GUID
pageContext.site.absoluteUrl             // Site collection URL
pageContext.site.id                      // Site collection GUID
pageContext.user.displayName             // Current user display name
pageContext.user.loginName               // Current user login name
pageContext.user.email                   // Current user email
pageContext.user.isAnonymousGuestUser    // Is anonymous guest
pageContext.list?.title                  // List title (if in list context)
pageContext.list?.id                     // List GUID (if in list context)
pageContext.listItem?.id                 // Item ID (if viewing/editing item)
pageContext.cultureInfo.currentCultureName         // e.g., "en-US"
pageContext.cultureInfo.currentUICultureName       // UI locale
pageContext.cultureInfo.isRightToLeft              // RTL language
pageContext.aadInfo.tenantId             // Azure AD tenant ID
pageContext.sdks.microsoftTeams          // Teams SDK (if in Teams)
```

**Key Features:**
- Lazy consumption from ServiceScope (only when hook is used)
- Cached with useMemo for performance
- Type-safe with native SPFx PageContext type
- Access to all SPFx context properties in one object

**Use Cases:**
- **Site Navigation**: Build breadcrumbs, navigation menus
- **User Display**: Show current user information, profile
- **Conditional Rendering**: Based on site type, list type, item context
- **Logging/Diagnostics**: Include site/web/user context in logs
- **URL Construction**: Build absolute URLs for REST API calls
- **Locale-Aware UI**: Adapt UI based on culture settings
- **Teams Integration**: Detect Teams context and adapt UI
- **Permission Checks**: Access permission information

**Example - Site breadcrumb with user info:**
```typescript
import { useSPFxPageContext } from '@apvee/spfx-react-toolkit';

function SiteHeader() {
  const pageContext = useSPFxPageContext();
  
  // Build breadcrumb items from site hierarchy
  const breadcrumbItems = [
    {
      text: 'Root',
      key: 'root',
      href: pageContext.site.absoluteUrl
    },
    {
      text: pageContext.web.title,
      key: 'current',
      href: pageContext.web.absoluteUrl,
      isCurrentItem: true
    }
  ];
  
  // Add list to breadcrumb if in list context
  if (pageContext.list) {
    breadcrumbItems.push({
      text: pageContext.list.title,
      key: 'list',
      href: `${pageContext.web.absoluteUrl}${pageContext.list.serverRelativeUrl}`,
      isCurrentItem: !pageContext.listItem
    });
  }
  
  // Add list item to breadcrumb if viewing/editing item
  if (pageContext.listItem) {
    breadcrumbItems.push({
      text: `Item ${pageContext.listItem.id}`,
      key: 'item',
      isCurrentItem: true
    });
  }
  
  return (
    <div style={{ 
      padding: '16px', 
      borderBottom: '1px solid #edebe9',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    }}>
      <div>
        <Breadcrumb items={breadcrumbItems} />
        
        <div style={{ marginTop: '8px', fontSize: '12px', color: '#666' }}>
          <div>
            <strong>Site:</strong> {pageContext.site.absoluteUrl}
          </div>
          <div>
            <strong>Web:</strong> {pageContext.web.absoluteUrl}
          </div>
          {pageContext.list && (
            <div>
              <strong>List:</strong> {pageContext.list.title} 
              (ID: {pageContext.list.id.toString()})
            </div>
          )}
          <div>
            <strong>Locale:</strong> {pageContext.cultureInfo.currentCultureName}
            {pageContext.cultureInfo.isRightToLeft && ' (RTL)'}
          </div>
          {pageContext.sdks.microsoftTeams && (
            <div>
              <strong>Teams Context:</strong> Yes
            </div>
          )}
        </div>
      </div>
      
      <div>
        <Persona
          text={pageContext.user.displayName}
          secondaryText={pageContext.user.email}
          size={PersonaSize.size40}
          imageUrl={`/_layouts/15/userphoto.aspx?size=M&username=${pageContext.user.loginName}`}
        />
        {pageContext.user.isAnonymousGuestUser && (
          <div style={{ fontSize: '11px', color: '#a4262c', marginTop: '4px' }}>
            (Anonymous Guest)
          </div>
        )}
      </div>
    </div>
  );
}
```

**Best Practices:**
- ✅ Use higher-level hooks (useSPFxSiteInfo, useSPFxUserInfo) for specific data when possible
- ✅ Check for optional properties (list, listItem) before accessing
- ✅ Use PageContext for comprehensive context when multiple properties needed
- ✅ Memoize derived values computed from PageContext
- ✅ Use pageContext.web.absoluteUrl for constructing absolute URLs
- ✅ Check pageContext.sdks.microsoftTeams for Teams-specific features
- ✅ Use pageContext.cultureInfo for locale-aware rendering
- ✅ Include PageContext data in diagnostic logs
- ❌ Don't access pageContext.list without checking for undefined
- ❌ Don't assume all properties are always present (some are context-dependent)
- ❌ Don't use PageContext for simple single-property access (use specific hooks)
- ❌ Don't ignore isAnonymousGuestUser (important for permissions)
- ❌ Don't hardcode URLs (use PageContext properties)

#### `useSPFxPageType()`
**Purpose**: Detect SharePoint page type with automatic classification  
**Returns**: `SPFxPageTypeInfo`  
**Use Case**: Feature gating, conditional rendering, page-specific behavior, analytics, compatibility checks

**Description:**  
Detects the current SharePoint page type by analyzing PageContext properties (both modern and legacy). Uses multi-level detection: modern page.type → legacy pageContext.pageType → inference from context (list ID, form type).

**Return Type:**
```typescript
interface SPFxPageTypeInfo {
  readonly pageType: SPFxPageType;      // 'sitePage' | 'webPartPage' | 'listPage' | 'listFormPage' | 'profilePage' | 'searchPage' | 'unknown'
  readonly isModernPage: boolean;       // True for modern site pages (sitePage)
  readonly isSitePage: boolean;         // True for site pages (modern)
  readonly isListPage: boolean;         // True for list view pages
  readonly isListFormPage: boolean;     // True for list form pages
  readonly isWebPartPage: boolean;      // True for classic web part pages
}
```

**Page Types:**
- `sitePage` - Modern site page (Site Pages library)
- `webPartPage` - Classic web part page
- `listPage` - List view page
- `listFormPage` - List form (new/edit/display item)
- `profilePage` - User profile page
- `searchPage` - Search results page
- `unknown` - Unable to determine

**Detection Strategy:**
1. Modern page.type (check first)
2. Legacy pageContext.pageType (fallback)
3. Context inference (list ID, form type)
4. Helper flags (boolean checks)

**Key Features:**
- Multi-level detection (modern → legacy → inference)
- Type-safe with TypeScript enums and boolean flags
- No external dependencies (uses PageContext only)
- Handles both modern and classic pages
- Supports list context detection (view vs form)
- Cached detection (PageContext is memoized)

**Use Cases:**
- **Feature Gating**: Enable/disable features based on page type
- **Conditional Rendering**: Different UI for modern vs classic
- **Page-Specific Behavior**: Adapt component per page type
- **Analytics/Telemetry**: Track usage by page type
- **Compatibility Checks**: Detect classic pages for fallback UI
- **Form Customization**: Identify list forms for field customizers
- **List View Customization**: Detect list views for view formatters

**Example - Feature gating with fallback:**
```typescript
import { useSPFxPageType } from '@apvee/spfx-react-toolkit';

function AdaptiveComponent() {
  const { 
    pageType, 
    isModernPage, 
    isSitePage, 
    isListPage,
    isListFormPage,
    isWebPartPage 
  } = useSPFxPageType();
  
  // Feature only available on modern site pages
  if (!isModernPage) {
    return (
      <MessageBar messageBarType={MessageBarType.warning}>
        <strong>Modern Page Required</strong>
        <p>
          This feature is only available on modern SharePoint pages.
          Current page type: <code>{pageType}</code>
        </p>
        {isWebPartPage && (
          <p>
            You are on a classic web part page. 
            Consider migrating to a modern site page for full functionality.
          </p>
        )}
      </MessageBar>
    );
  }
  
  // Different UI for different page types
  return (
    <div style={{ padding: '16px' }}>
      <h2>Adaptive Component</h2>
      
      <div style={{ marginBottom: '16px' }}>
        <strong>Page Type:</strong> {pageType}
      </div>
      
      {isSitePage && (
        <div>
          <h3>Site Page Features</h3>
          <ul>
            <li>✅ Modern UI components</li>
            <li>✅ Fluent Design System</li>
            <li>✅ Responsive layout</li>
            <li>✅ Section backgrounds</li>
          </ul>
          <ModernPageFeature />
        </div>
      )}
      
      {isListPage && (
        <div>
          <h3>List View Customizer</h3>
          <p>Detected list view page. Showing list-specific features:</p>
          <ListViewCustomizer />
          <ListViewCommands />
        </div>
      )}
      
      {isListFormPage && (
        <div>
          <h3>List Form Customizer</h3>
          <p>Detected list form page. Showing form-specific features:</p>
          <FormFieldCustomizer />
          <FormValidationRules />
        </div>
      )}
      
      {isWebPartPage && (
        <div>
          <MessageBar messageBarType={MessageBarType.info}>
            <strong>Classic Page Detected</strong>
            <p>Using compatibility mode for classic web part pages.</p>
          </MessageBar>
          <ClassicFallbackUI />
        </div>
      )}
    </div>
  );
}

// Modern-only feature with graceful degradation
function ModernPageFeature() {
  const { isModernPage, pageType } = useSPFxPageType();
  
  if (!isModernPage) {
    return (
      <div style={{ padding: '8px', backgroundColor: '#fff4ce', borderRadius: '4px' }}>
        <strong>Limited Functionality</strong>
        <p>Some features are disabled on {pageType} pages.</p>
      </div>
    );
  }
  
  return (
    <div>
      <h4>Modern Page Feature Enabled</h4>
      <p>Full functionality available with modern components.</p>
    </div>
  );
}
```

**Best Practices:**
- ✅ Use boolean flags (isModernPage, isSitePage) for simple checks
- ✅ Check pageType for granular page type detection
- ✅ Provide fallback UI for classic pages when feature requires modern
- ✅ Use for feature gating (enable/disable based on page type)
- ✅ Track page type in analytics for usage insights
- ✅ Test components on all page types (modern, classic, list, form)
- ✅ Show informative messages when features are page-type specific
- ✅ Use isListPage/isListFormPage for list-specific customizations
- ✅ Consider graceful degradation for classic compatibility
- ❌ Don't assume all pages are modern (test on classic pages)
- ❌ Don't ignore unknown page type (handle gracefully)
- ❌ Don't use hard-coded page type checks (use this hook)
- ❌ Don't forget isModernPage only includes sitePage
- ❌ Don't show errors for unsupported pages (show informative messages)

#### `useSPFxEnvironmentInfo()`
**Purpose**: Detect execution environment  
**Returns**: `SPFxEnvironmentInfo`  
**Use Case**: Environment-specific behavior, feature availability, API endpoint selection, mock data in local workbench

**Description:**  
Detects the current host environment where the SPFx component is running. Uses priority-based detection: Local > Teams > Outlook > Office > SharePointOnPrem > SharePoint. Essential for environment-specific rendering, feature toggling, and API configuration.

**Return Type:**
```typescript
interface SPFxEnvironmentInfo {
  readonly type: SPFxEnvironmentType;           // 'Local' | 'SharePoint' | 'SharePointOnPrem' | 'Teams' | 'Office' | 'Outlook'
  readonly isLocal: boolean;                    // Running in local workbench (localhost/127.0.0.1)
  readonly isWorkbench: boolean;                // Running in any workbench (local or hosted)
  readonly isSharePoint: boolean;               // SharePoint Online
  readonly isSharePointOnPrem: boolean;         // SharePoint On-Premises
  readonly isTeams: boolean;                    // Microsoft Teams
  readonly isOffice: boolean;                   // Office application
  readonly isOutlook: boolean;                  // Outlook
}
```

**Key Features:**
- Priority-based detection algorithm (Local has highest priority)
- Boolean helpers for all environment types
- Workbench detection (local or hosted)
- SDK-based detection for Teams/Office/Outlook (via `pageContext.sdks`)
- Support for SharePoint On-Premises detection
- Reliable localhost detection (127.0.0.1 or localhost)

**Example - Environment-specific rendering:**
```typescript
import { useSPFxEnvironmentInfo } from '@apvee/spfx-react-toolkit';

function AdaptiveUI() {
  const { type, isTeams, isLocal } = useSPFxEnvironmentInfo();
  
  if (isLocal) {
    return (
      <Stack tokens={{ childrenGap: 8 }}>
        <MessageBar messageBarType={MessageBarType.warning}>
          Running in local workbench - using mock data
        </MessageBar>
        <DevModeBanner />
      </Stack>
    );
  }
  
  if (isTeams) {
    return <TeamsOptimizedUI />;
  }
  
  return <SharePointUI />;
}
```

**Best Practices:**
- ✅ Use for environment-specific feature toggling
- ✅ Show clear warnings when using mock data in local workbench
- ✅ Select appropriate API endpoints based on environment
- ✅ Hide debug information in production (check `!isLocal && !isWorkbench`)
- ✅ Optimize UI for Teams context when `isTeams` is true
- ✅ Use boolean helpers (`isLocal`, `isTeams`, etc.) for cleaner conditional logic
- ✅ Cache environment checks in useMemo if used multiple times in a component
- ✅ Handle SharePoint On-Premises scenarios separately from Online
- ❌ Don't assume SharePoint-specific features work in all environments (e.g., Teams)
- ❌ Don't expose sensitive debug information in production
- ❌ Don't hardcode environment-specific logic without checking environment first
- ❌ Don't forget to handle all environment types in switch statements

### `useSPFxTeams()`
**Purpose**: Microsoft Teams context with automatic SDK initialization (v1 and v2 compatible)  
**Returns**: `SPFxTeamsInfo`
```typescript
interface SPFxTeamsInfo {
  readonly supported: boolean;                      // Teams context available
  readonly context: unknown | undefined;           // Teams context object
  readonly theme: TeamsTheme | undefined;          // 'default' | 'dark' | 'highContrast'
}

type TeamsTheme = 'default' | 'dark' | 'highContrast';
```

**Use Cases**: Teams-specific features, theme synchronization, user context, team/channel info, conditional rendering, Teams integration, channel tabs, personal apps

**Key Features**:
- Automatic SDK detection (v1 or v2)
- Async initialization (non-blocking)
- Theme support (default, dark, highContrast)
- Context access (team, channel, user info)
- Environment detection (supported flag)
- Version compatibility (v1 and v2 APIs)
- Global state (Jotai atom)
- One-time init per app lifecycle

**Implementation Details**:
- Reads from spfxAtoms.teams using useAtom
- Initializes on first mount (useEffect with initialized flag)
- Tries v2 API first (app.getContext()), falls back to v1 (getContext callback)
- Normalizes theme from context (handles case variations)
- Stores result in atom (shared across components)
- Disposed flag prevents state updates after unmount

**Example - Teams Integration:**
```typescript
interface ITeamsContext {
  user?: {
    id: string;
    userPrincipalName: string;
    displayName?: string;
  };
  team?: {
    displayName: string;
    internalId: string;
  };
  channel?: {
    displayName: string;
    id: string;
  };
  theme?: string; // v1
  app?: { theme?: string }; // v2
}

function TeamsIntegration() {
  const { supported, context, theme } = useSPFxTeams();
  
  if (!supported) {
    return (
      <MessageBar messageBarType={MessageBarType.info}>
        Optimized for Teams but works in SharePoint too.
      </MessageBar>
    );
  }
  
  const teamsContext = context as ITeamsContext;
  const themeClass = `teams-theme-${theme || 'default'}`;
  
  return (
    <Stack className={themeClass} tokens={{ childrenGap: 15 }}>
      <Stack horizontal verticalAlign="center" tokens={{ childrenGap: 10 }}>
        <Icon iconName="TeamsLogo" styles={{ root: { fontSize: 32 } }} />
        <Text variant="xLarge">Running in Microsoft Teams</Text>
      </Stack>
      
      {teamsContext.team && (
        <MessageBar messageBarType={MessageBarType.success}>
          <Stack tokens={{ childrenGap: 5 }}>
            <Text><strong>Team:</strong> {teamsContext.team.displayName}</Text>
            {teamsContext.channel && (
              <Text><strong>Channel:</strong> {teamsContext.channel.displayName}</Text>
            )}
          </Stack>
        </MessageBar>
      )}
      
      {teamsContext.user && (
        <Stack tokens={{ childrenGap: 5 }}>
          <Text><strong>User:</strong> {teamsContext.user.displayName || teamsContext.user.userPrincipalName}</Text>
          <Text variant="small">User ID: {teamsContext.user.id}</Text>
        </Stack>
      )}
      
      <Stack horizontal tokens={{ childrenGap: 10 }}>
        <Label>Theme:</Label>
        <Badge appearance="filled" color={theme === 'dark' ? 'dark' : 'success'}>
          {theme}
        </Badge>
      </Stack>
      
      <Stack tokens={{ childrenGap: 10 }}>
        <Text variant="large">Teams-Only Features</Text>
        <PrimaryButton
          text="Open Task Module"
          iconProps={{ iconName: 'OpenInNewWindow' }}
          onClick={() => console.log('Open task module')}
        />
        <DefaultButton
          text="Send Adaptive Card"
          iconProps={{ iconName: 'MessageFill' }}
          onClick={() => console.log('Send adaptive card')}
        />
      </Stack>
    </Stack>
  );
}
```

**Best Practices**:
✅ Check `supported` flag before accessing context/theme
✅ Cast context to appropriate type for Teams SDK version
✅ Provide fallback UI for non-Teams environments
✅ Use theme value for visual consistency
✅ Handle undefined values gracefully
✅ Use Teams context for deep linking
✅ Test in both Teams and SharePoint
✅ Use Teams-specific features only when supported
✅ Document which Teams SDK version your types use
✅ Memoize context parsing to avoid repeated casting

❌ Don't assume `supported` is always true
❌ Don't access context without checking defined
❌ Don't hardcode Teams logic without checking supported
❌ Don't forget context structure differs between v1/v2
❌ Don't ignore theme value
❌ Don't use Teams APIs without checking supported
❌ Don't assume team/channel always present
❌ Don't store sensitive data in state
❌ Don't call conditionally
❌ Don't manually initialize Teams SDK

---

### User & Site Information

### `useSPFxUserInfo()`
**Purpose**: Access current user information  
**Returns**: `SPFxUserInfo`
```typescript
interface SPFxUserInfo {
  readonly loginName: string;      // User login identifier (e.g., "i:0#.f|membership|user@contoso.com")
  readonly displayName: string;    // User display name (e.g., "John Doe")
  readonly email: string | undefined;  // User email (may be undefined)
  readonly isExternal: boolean;    // External guest user flag
}
```

**Parameters**: None

**Use Cases**: Personalization, authorization, logging, user profiles, email links, guest warnings, audit trails, user-specific content filtering

**Key Features**:
- Current authenticated user from SPFx context
- Display name for personalization
- Email access when available
- Guest detection (isExternal flag)
- Login name for unique identification
- Zero dependencies (uses PageContext)
- Type-safe interface
- Always available in SPFx

**Example - User Welcome Panel with Full Features:**
```typescript
function UserWelcomePanel() {
  const { displayName, email, loginName, isExternal } = useSPFxUserInfo();
  
  return (
    <Stack tokens={{ childrenGap: 16 }} styles={{ root: { padding: 20 } }}>
      {/* Welcome with Persona */}
      <Stack horizontal verticalAlign="center" tokens={{ childrenGap: 12 }}>
        <Persona
          text={displayName}
          secondaryText={email || 'No email'}
          size={PersonaSize.size48}
          imageUrl={`/_layouts/15/userphoto.aspx?size=M&username=${email || loginName}`}
        />
        <Stack>
          <Text variant="xLarge" styles={{ root: { fontWeight: 600 } }}>
            Welcome, {displayName}!
          </Text>
          {email && <Text variant="small">{email}</Text>}
        </Stack>
      </Stack>
      
      {/* Guest warning */}
      {isExternal && (
        <MessageBar messageBarType={MessageBarType.warning}>
          <strong>Guest User:</strong> Limited access. Some features restricted.
        </MessageBar>
      )}
      
      {/* User actions */}
      <Stack horizontal tokens={{ childrenGap: 10 }}>
        {email && (
          <a href={`mailto:${email}`} style={{ padding: '8px 16px', backgroundColor: '#0078d4', color: 'white' }}>
            📧 Email Me
          </a>
        )}
        <a href={`/_layouts/15/userdisp.aspx?ID=${loginName}`} style={{ padding: '8px 16px' }}>
          👤 View Profile
        </a>
      </Stack>
      
      {/* User details card */}
      <Stack styles={{ root: { backgroundColor: '#f9f9f9', padding: 16 } }} tokens={{ childrenGap: 8 }}>
        <Text variant="medium" styles={{ root: { fontWeight: 600 } }}>User Details</Text>
        
        <Stack tokens={{ childrenGap: 4 }}>
          <Stack horizontal tokens={{ childrenGap: 8 }}>
            <Text styles={{ root: { fontWeight: 600, minWidth: 100 } }}>Display Name:</Text>
            <Text>{displayName}</Text>
          </Stack>
          
          <Stack horizontal tokens={{ childrenGap: 8 }}>
            <Text styles={{ root: { fontWeight: 600, minWidth: 100 } }}>Email:</Text>
            <Text>{email || 'Not available'}</Text>
          </Stack>
          
          <Stack horizontal tokens={{ childrenGap: 8 }}>
            <Text styles={{ root: { fontWeight: 600, minWidth: 100 } }}>Login Name:</Text>
            <Text styles={{ root: { fontFamily: 'monospace', fontSize: 12 } }}>{loginName}</Text>
          </Stack>
          
          <Stack horizontal tokens={{ childrenGap: 8 }}>
            <Text styles={{ root: { fontWeight: 600, minWidth: 100 } }}>User Type:</Text>
            <Text>{isExternal ? '🌐 External Guest' : '✓ Internal User'}</Text>
          </Stack>
        </Stack>
      </Stack>
      
      {/* Conditional content */}
      {!isExternal && (
        <Stack styles={{ root: { backgroundColor: '#e8f4fd', padding: 16 } }}>
          <Text variant="medium" styles={{ root: { fontWeight: 600 } }}>Internal User Benefits</Text>
          <ul>
            <li>Full access to all site content</li>
            <li>Can create and edit documents</li>
            <li>Access to internal tools</li>
          </ul>
        </Stack>
      )}
      
      {/* Activity log */}
      <Stack styles={{ root: { backgroundColor: '#fff', padding: 16, border: '1px solid #e1e1e1' } }}>
        <Text variant="medium" styles={{ root: { fontWeight: 600 } }}>Recent Activity</Text>
        <Text styles={{ root: { fontSize: 12, fontFamily: 'monospace' } }}>
          {new Date().toLocaleString()} - User {displayName} ({loginName}) accessed this component
          {isExternal && ' [GUEST]'}
        </Text>
      </Stack>
    </Stack>
  );
}

// User-specific filtering
function MyDocumentsView() {
  const { loginName } = useSPFxUserInfo();
  const { items, isLoading } = useSPFxPnPList('Documents', {
    filter: `Author/Name eq '${loginName}'`
  });
  
  if (isLoading) return <Spinner />;
  return items.map(doc => <div key={doc.Id}>{doc.Title}</div>);
}

// Audit logging
function AuditedButton() {
  const { displayName, loginName } = useSPFxUserInfo();
  const logger = useSPFxLogger();
  
  const handleClick = () => {
    logger.info('Button clicked', { user: displayName, loginName, timestamp: new Date().toISOString() });
  };
  
  return <PrimaryButton onClick={handleClick}>Perform Action</PrimaryButton>;
}
```

**Best Practices**:
✅ Use displayName for user-facing text
✅ Check if email is defined before using
✅ Use loginName for unique identification
✅ Show conditional UI based on isExternal
✅ Combine with useSPFxPermissions for authorization
✅ Use email for mailto links when available
✅ Include user context in audit logs
✅ Handle guest users gracefully
✅ Use loginName for filtering by author
✅ Show user photos with userphoto.aspx

❌ Don't assume email is always available
❌ Don't use loginName for display
❌ Don't expose sensitive data without checks
❌ Don't hardcode user checks
❌ Don't forget guest user scenarios
❌ Don't use for authentication
❌ Don't store unnecessarily in state
❌ Don't assume loginName format
❌ Don't bypass permission checks
❌ Don't forget GDPR/privacy considerations

---

### `useSPFxSiteInfo()`
**Purpose**: Access site collection and web information with flat, predictable property naming  
**Returns**: `SPFxSiteInfo`
```typescript
interface SPFxSiteInfo {
  // Web properties (primary context - 90% use case)
  readonly webId: string;                      // Web ID (GUID)
  readonly webUrl: string;                     // Web absolute URL
  readonly webServerRelativeUrl: string;       // Web server-relative URL
  readonly title: string;                      // Web display name (most common)
  readonly languageId: number;                 // Web language (LCID)
  readonly logoUrl: string | undefined;        // Site logo URL (branding)
  
  // Site collection properties (parent context - specialized)
  readonly siteId: string;                     // Site collection ID (GUID)
  readonly siteUrl: string;                    // Site collection absolute URL
  readonly siteServerRelativeUrl: string;      // Site collection server-relative URL
  readonly siteClassification: string | undefined;  // Enterprise classification label
  readonly siteGroup: SPFxGroupInfo | undefined;    // M365 Group info (if group-connected)
}

interface SPFxGroupInfo {
  readonly id: string;                         // Group ID (GUID)
  readonly isPublic: boolean;                  // Public vs private group
}
```

**Use Cases**: Site headers, breadcrumb navigation, branding, classification display, team detection, language-specific features, multi-site apps, URL construction

**Key Features**:
- Flat structure with clear prefixes (web/site for identity, no prefix for unique web properties)
- Web-first design (title, languageId most common)
- M365 Group detection (siteGroup)
- Enterprise classification support (siteClassification)
- Branding support (logoUrl)
- Subsite navigation (separate webUrl and siteUrl)
- Language support (languageId LCID)

**Implementation Details**:
- Reads from PageContext.site and PageContext.web
- Uses legacyPageContext for siteClassification
- Converts GUIDs to strings
- Defaults languageId to 1033 (English) if unavailable
- logoUrl from webObj (may be undefined)
- siteGroup from siteObj.group (undefined if not group-connected)

**Example**:
```typescript
function SiteHeader() {
  const { 
    title, webUrl, webId, languageId, logoUrl,
    siteUrl, siteClassification, siteGroup
  } = useSPFxSiteInfo();
  
  return (
    <Stack horizontal verticalAlign="center" tokens={{ childrenGap: 15 }}>
      {/* Logo and title */}
      {logoUrl && <img src={logoUrl} alt="Logo" style={{ width: 32, height: 32 }} />}
      <Stack>
        <Text variant="xLarge">{title}</Text>
        <Link href={webUrl}>Visit Site</Link>
      </Stack>
      
      {/* Classification */}
      {siteClassification && (
        <MessageBar messageBarType={MessageBarType.warning}>
          <strong>Classification:</strong> {siteClassification}
        </MessageBar>
      )}
      
      {/* M365 Group badge */}
      {siteGroup && (
        <Badge color={siteGroup.isPublic ? 'success' : 'info'}>
          {siteGroup.isPublic ? '🌐 Public Team' : '🔒 Private Team'}
        </Badge>
      )}
      
      <Text variant="small">Language: {languageId}</Text>
    </Stack>
  );
}

// Breadcrumb with site hierarchy
function SiteBreadcrumb() {
  const { title, webUrl, siteUrl, webServerRelativeUrl, siteServerRelativeUrl } = 
    useSPFxSiteInfo();
  
  const isSubsite = webServerRelativeUrl !== siteServerRelativeUrl;
  
  return (
    <Breadcrumb>
      <BreadcrumbItem><Link href={siteUrl}>Site Collection</Link></BreadcrumbItem>
      {isSubsite && <BreadcrumbItem><Link href={webUrl}>{title}</Link></BreadcrumbItem>}
      {!isSubsite && <BreadcrumbItem isCurrentItem>{title}</BreadcrumbItem>}
    </Breadcrumb>
  );
}
```

**Best Practices**:
✅ Use `title` for display name (most common)
✅ Check for undefined on optional properties
✅ Use `webUrl` for current site, `siteUrl` for collection root
✅ Compare serverRelativeUrls to detect subsites
✅ Use siteClassification for governance displays
✅ Use siteGroup.isPublic for public/private teams
✅ Use languageId for locale-specific logic
✅ Destructure only needed properties
✅ Use logoUrl for branding
✅ Validate URLs before navigation

❌ Don't assume logoUrl is defined
❌ Don't confuse webUrl and siteUrl
❌ Don't assume siteClassification exists
❌ Don't use siteGroup without checking undefined
❌ Don't hardcode site URLs
❌ Don't ignore languageId for i18n
❌ Don't use for user info
❌ Don't store in React state
❌ Don't call conditionally
❌ Don't mutate returned properties

---

#### `useSPFxLocaleInfo()`
**Purpose**: Locale and regional settings for internationalization  
**Returns**: `SPFxLocaleInfo`  
**Use Case**: i18n, date/time/number formatting, RTL layout, calendar widgets, multi-lingual apps

**Description:**  
Provides comprehensive locale and regional information from SPFx PageContext. Uses native SPFx properties (cultureInfo.currentCultureName, cultureInfo.currentUICultureName, cultureInfo.isRightToLeft, web.timeZoneInfo) for accurate regional settings. Locale strings are BCP 47 compliant and directly compatible with JavaScript Intl APIs.

**Return Type:**
```typescript
interface SPFxLocaleInfo {
  readonly locale: string;                 // Content locale (e.g., "en-US", "it-IT")
  readonly uiLocale: string;               // UI language locale
  readonly timeZone: SPFxTimeZone | undefined; // Time zone info (preview API)
  readonly isRtl: boolean;                 // Right-to-left language detection
}

interface SPFxTimeZone {
  readonly id: number;              // Time zone ID
  readonly offset: number;          // Offset in minutes from UTC
  readonly description: string;     // Description (e.g., "Pacific Standard Time")
  readonly daylightOffset: number;  // DST offset in minutes from UTC
  readonly standardOffset: number;  // Standard time offset in minutes from UTC
}
```

**Key Features:**
- Native SPFx properties (no legacy context)
- Direct compatibility with JavaScript Intl APIs
- Time zone information with DST support (preview API, may be undefined)
- Right-to-left language detection from cultureInfo
- Content locale vs UI locale distinction
- BCP 47 compliant locale strings

**JavaScript Intl API Compatibility:**
The locale string works directly with:
- `Intl.DateTimeFormat(locale, options)` - Date/time formatting
- `Intl.NumberFormat(locale, options)` - Number/currency formatting
- `Intl.Collator(locale, options)` - String comparison/sorting
- `Intl.RelativeTimeFormat(locale, options)` - Relative time ("2 days ago")
- `Intl.PluralRules(locale, options)` - Plural form selection

**Use Cases:**
- **Date/Time Formatting**: Locale-aware date and time display
- **Number/Currency Formatting**: Regional number and currency display
- **RTL Layout**: Conditional CSS for right-to-left languages (Arabic, Hebrew)
- **Multi-lingual Applications**: Display content in user's preferred language
- **Calendar Widgets**: Time zone aware event scheduling
- **String Comparison**: Locale-aware sorting with Intl.Collator
- **Regional Preferences**: Adapt UI based on regional conventions

**Example - Comprehensive i18n with time zone:**
```typescript
import { useSPFxLocaleInfo } from '@apvee/spfx-react-toolkit';

function InternationalDateDisplay() {
  const { locale, uiLocale, timeZone, isRtl } = useSPFxLocaleInfo();
  const [currentTime, setCurrentTime] = useState(new Date());
  
  // Update time every second
  useEffect(() => {
    const timer = setInterval(() => setCurrentTime(new Date()), 1000);
    return () => clearInterval(timer);
  }, []);
  
  // Format date with locale
  const formatDate = (date: Date) => {
    return new Intl.DateTimeFormat(locale, {
      dateStyle: 'full',
      timeStyle: 'long'
    }).format(date);
  };
  
  // Format currency with locale
  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: 'USD'
    }).format(amount);
  };
  
  // Format relative time
  const formatRelativeTime = (days: number) => {
    const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
    return rtf.format(days, 'day');
  };
  
  return (
    <div 
      dir={isRtl ? 'rtl' : 'ltr'} 
      style={{ 
        padding: '16px',
        textAlign: isRtl ? 'right' : 'left'
      }}
    >
      <h3>Internationalization Demo</h3>
      
      <div style={{ marginBottom: '8px' }}>
        <strong>Content Locale:</strong> {locale}
      </div>
      <div style={{ marginBottom: '8px' }}>
        <strong>UI Locale:</strong> {uiLocale}
      </div>
      <div style={{ marginBottom: '8px' }}>
        <strong>Direction:</strong> {isRtl ? 'Right-to-Left (RTL)' : 'Left-to-Right (LTR)'}
      </div>
      
      {timeZone && (
        <div style={{ marginBottom: '8px' }}>
          <strong>Time Zone:</strong> {timeZone.description}
          <br />
          <small>UTC Offset: {timeZone.offset / 60} hours</small>
        </div>
      )}
      
      <hr />
      
      <div style={{ marginTop: '16px' }}>
        <div><strong>Current Date/Time:</strong></div>
        <div>{formatDate(currentTime)}</div>
      </div>
      
      <div style={{ marginTop: '12px' }}>
        <div><strong>Currency Example:</strong></div>
        <div>{formatCurrency(1234.56)}</div>
      </div>
      
      <div style={{ marginTop: '12px' }}>
        <div><strong>Relative Time:</strong></div>
        <div>{formatRelativeTime(-3)} | {formatRelativeTime(5)}</div>
      </div>
    </div>
  );
}
```

**Best Practices:**
- ✅ Use `locale` with JavaScript Intl APIs for formatting
- ✅ Apply `dir={isRtl ? 'rtl' : 'ltr'}` to container elements for RTL support
- ✅ Check `timeZone` for undefined before accessing properties (preview API)
- ✅ Use `uiLocale` for UI strings, `locale` for data formatting
- ✅ Cache formatted values when rendering lists (Intl formatters are expensive)
- ✅ Test with multiple locales (en-US, ar-SA for RTL, de-DE for date formats)
- ✅ Consider fallback locales for unsupported regions
- ✅ Use `Intl.DateTimeFormat().resolvedOptions()` to inspect actual formatting
- ✅ Memoize Intl formatters to avoid recreation on every render
- ❌ Don't hardcode date/time/number formats (use Intl APIs)
- ❌ Don't assume locale format (US: MM/DD/YYYY vs EU: DD/MM/YYYY)
- ❌ Don't forget RTL layout adjustments (padding, margins, icons, text alignment)
- ❌ Don't use `timeZone` without checking for undefined (it's a preview API)
- ❌ Don't create new Intl formatters on every render (use useMemo or create once)

#### `useSPFxListInfo()`
**Purpose**: Access list information when in list context  
**Returns**: `SPFxListInfo | undefined`  
**Use Case**: Field Customizers, ListView Command Sets, list-scoped WebParts, conditional rendering based on list type

**Description:**  
Provides detailed information about the current SharePoint list or library when component is rendered in a list context. Returns `undefined` if not in a list context. List context is available in Field Customizers, ListView Command Sets, and some list-scoped WebParts. Standard page WebParts typically don't have list context.

**Return Type:**
```typescript
interface SPFxListInfo {
  readonly id: string;                  // List ID (GUID)
  readonly title: string;               // List title (default: "Unknown List")
  readonly serverRelativeUrl: string;   // List server-relative URL
  readonly baseTemplate?: number;       // List template type (100 = List, 101 = Library)
  readonly isDocumentLibrary?: boolean; // True if baseTemplate === 101
}
```

**Key Features:**
- Returns `undefined` if not in list context (always check before use)
- Automatic document library detection via baseTemplate comparison
- Extracted from PageContext.list
- Available in Field Customizers and list-scoped components
- Safe defaults for missing values (title defaults to "Unknown List")
- ID converted to string for consistency

**List Context Availability:**
- ✅ **Field Customizers** - Always available (rendering within list view)
- ✅ **ListView Command Sets** - Always available (list action context)
- ✅ **List-scoped WebParts** - Sometimes available (depends on WebPart configuration)
- ❌ **Standard Page WebParts** - Typically not available
- ❌ **Application Customizers** - Not available (page-level, not list-specific)

**Common List Template Types:**
- `100` - Generic List (custom lists)
- `101` - Document Library (file storage)
- `102` - Survey
- `103` - Links
- `104` - Announcements
- `105` - Contacts
- `106` - Events (Calendar)
- `107` - Tasks
- `108` - Discussion Board
- `109` - Picture Library
- `119` - Wiki Page Library

**Use Cases:**
- **Field Customizers**: Access list metadata for custom field rendering
- **Conditional Rendering**: Different UI based on list type (list vs library)
- **List URLs**: Build URLs to list views or items
- **List Metadata Display**: Show list title, type, or ID
- **Document Library Features**: Enable library-specific features (upload, folders, versioning)
- **List-specific Operations**: Filter data based on list properties
- **Template Detection**: Conditional logic based on list template type

**Example - Field Customizer with list metadata:**
```typescript
import { useSPFxListInfo } from '@apvee/spfx-react-toolkit';

function FieldRenderer() {
  const list = useSPFxListInfo();
  
  // Not in list context (e.g., standard WebPart on page)
  if (!list) {
    return <div>Not available in list context</div>;
  }
  
  // Render list metadata
  return (
    <div style={{ padding: '8px' }}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
        {list.isDocumentLibrary ? (
          <Icon iconName="FabricFolder" title="Document Library" />
        ) : (
          <Icon iconName="BulletedList" title="List" />
        )}
        <strong>{list.title}</strong>
      </div>
      
      <div style={{ fontSize: '12px', color: '#666', marginTop: '4px' }}>
        <div>ID: {list.id}</div>
        <div>URL: {list.serverRelativeUrl}</div>
        {list.baseTemplate && (
          <div>Template: {list.baseTemplate}</div>
        )}
      </div>
      
      {list.isDocumentLibrary && (
        <div style={{ marginTop: '8px', color: '#0078d4' }}>
          📁 Document Library Features Available
        </div>
      )}
    </div>
  );
}
```

**Best Practices:**
- ✅ Always check for `undefined` before accessing properties
- ✅ Use `isDocumentLibrary` helper for document library detection
- ✅ Display appropriate icons/UI based on list type
- ✅ Handle missing list context gracefully (show fallback or hide)
- ✅ Use list ID for API calls requiring list identifier
- ✅ Cache list info if used multiple times in component
- ✅ Test in both list and non-list contexts
- ✅ Use baseTemplate for fine-grained list type detection
- ❌ Don't assume list context is always available
- ❌ Don't use in standard WebParts without checking for undefined
- ❌ Don't hardcode list template numbers (use constants or add comments)
- ❌ Don't make API calls using list info without validating it first
- ❌ Don't rely on list context for security (always check permissions)

#### `useSPFxHubSiteInfo()`
**Purpose**: Hub site association information with automatic hub URL fetching  
**Returns**: `SPFxHubSiteInfo`  
**Use Case**: Hub navigation, hub branding, content rollup, hub-aware features, site hierarchy

**Description:**  
Provides comprehensive information about SharePoint Hub Site association. Hub Sites are a modern SharePoint feature enabling unified navigation, shared branding, content rollup, and centralized search across related sites. This hook detects hub association, retrieves hub ID from pageContext, and automatically fetches hub URL via REST API.

**Return Type:**
```typescript
interface SPFxHubSiteInfo {
  readonly isHubSite: boolean;           // Whether site is associated with a hub
  readonly hubSiteId: string | undefined; // Hub site ID (GUID) if associated
  readonly hubSiteUrl: string | undefined; // Hub site URL (fetched async)
  readonly isLoading: boolean;           // Loading state for hub URL fetch
  readonly error: Error | undefined;     // Error during hub URL fetch
}
```

**Hub Sites Overview:**
Hub Sites allow:
- Unified navigation across related sites
- Shared branding and theming
- Content rollup from associated sites
- Centralized search and navigation
- Logical grouping of related sites

**Key Features:**
- Automatic hub association detection from pageContext
- Asynchronous hub URL fetching via `_api/web/hubsitedata(false)` endpoint
- Optimization: If current site IS the hub, uses current URL directly (no API call)
- Loading and error states for hub URL fetch
- Handles empty GUID (`00000000-0000-0000-0000-000000000000`) correctly
- Site is hub-associated if hubSiteId exists and is not empty GUID

**Implementation Details:**
- Hub ID retrieved from `pageContext.legacyPageContext.hubSiteId`
- Hub URL fetched via `/_api/web/hubsitedata(false)` (returns nested JSON: `{ value: "JSON_STRING" }`)
- If current site is the hub (`isHubSite` flag in legacyPageContext), uses `webAbsoluteUrl` directly
- Empty GUID treated as "no hub"
- REST API call skipped if current site is the hub itself

**Example - Hub-aware navigation:**
```typescript
import { useSPFxHubSiteInfo } from '@apvee/spfx-react-toolkit';

function HubNavigation() {
  const { isHubSite, hubSiteId, hubSiteUrl, isLoading, error } = useSPFxHubSiteInfo();
  
  // Not part of a hub
  if (!isHubSite) {
    return null;
  }
  
  // Loading hub URL
  if (isLoading) {
    return <Spinner label="Loading hub info..." size={SpinnerSize.small} />;
  }
  
  // Error loading hub URL
  if (error) {
    console.error('Failed to load hub URL:', error);
    return null;
  }
  
  return (
    <nav style={{ padding: '8px', borderBottom: '1px solid #ccc' }}>
      <Link href={hubSiteUrl}>← Back to Hub</Link>
      <span style={{ marginLeft: '16px', color: '#666', fontSize: '12px' }}>
        Hub ID: {hubSiteId}
      </span>
    </nav>
  );
}
```

**Best Practices:**
- ✅ Check `isHubSite` before rendering hub-specific UI
- ✅ Handle `isLoading` state with spinners or skeletons
- ✅ Handle `error` state gracefully (log and hide or show fallback)
- ✅ Use `hubSiteUrl` for navigation links to hub
- ✅ Cache hub information when appropriate (it doesn't change often)
- ✅ Combine with `useSPFxThemeInfo()` for hub theme synchronization
- ✅ Test with sites that are hubs vs sites associated with hubs
- ✅ Optimize: Current site might BE the hub (no API call needed)
- ❌ Don't assume `hubSiteUrl` is available immediately (it's async)
- ❌ Don't ignore loading and error states
- ❌ Don't make assumptions about hub structure without checking `isHubSite`
- ❌ Don't forget that current site might BE the hub itself
- ❌ Don't poll for hub changes (hub association is static)

### UI & Theming

### `useSPFxThemeInfo()`
**Purpose**: Access current SPFx theme (Fluent UI 8) with automatic updates  
**Returns**: `IReadonlyTheme | undefined`
```typescript
interface IReadonlyTheme {
  readonly semanticColors: ISemanticColors;  // bodyBackground, bodyText, link, etc.
  readonly palette: IPalette;                // themePrimary, neutralPrimary, etc.
  readonly fonts: IFontStyles;               // small, medium, large, etc.
  readonly spacing: ISpacing;                // Spacing tokens
  readonly isInverted: boolean;              // Dark theme indicator
  readonly effects: IEffects;                // Border radius, shadows
}
```

**Parameters**: None

**Use Cases**: Custom styling, dark mode detection, theme-aware components, semantic colors, dynamic backgrounds, consistent UI

**Key Features**:
- Automatic updates when user switches themes
- SPFxProvider managed subscription
- Fluent UI 8 IReadonlyTheme object
- Semantic colors (bodyBackground, bodyText, link, etc.)
- Dark mode detection (isInverted)
- Zero overhead (direct atom read)
- Type-safe with IReadonlyTheme
- SharePoint native theme system

**Example - Themed Card with Full Features:**
```typescript
function ThemedCard() {
  const theme = useSPFxThemeInfo();
  
  if (!theme) return <div>Loading theme...</div>;
  
  const isDarkMode = theme.isInverted;
  
  return (
    <div
      style={{
        backgroundColor: theme.semanticColors.bodyBackground,
        color: theme.semanticColors.bodyText,
        border: `1px solid ${theme.semanticColors.bodyDivider}`,
        borderRadius: theme.effects.roundedCorner4,
        padding: theme.spacing.l1,
        boxShadow: theme.effects.elevation8,
        maxWidth: 600
      }}
    >
      <Stack tokens={{ childrenGap: 16 }}>
        {/* Header */}
        <Text
          variant="xLarge"
          styles={{ root: { color: theme.palette.themePrimary, fontWeight: 600 } }}
        >
          Themed Component
        </Text>
        
        <Separator />
        
        {/* Content */}
        <Stack tokens={{ childrenGap: 8 }}>
          <Text styles={{ root: { color: theme.semanticColors.bodyText } }}>
            Auto-adapts to SharePoint theme changes.
          </Text>
          
          <Text styles={{ root: { color: theme.semanticColors.bodySubtext } }}>
            Mode: <strong>{isDarkMode ? 'Dark' : 'Light'}</strong>
          </Text>
          
          {/* Themed link */}
          <a
            href="#"
            style={{
              color: theme.semanticColors.link,
              textDecoration: 'none'
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.color = theme.semanticColors.linkHovered || '';
              e.currentTarget.style.textDecoration = 'underline';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.color = theme.semanticColors.link;
              e.currentTarget.style.textDecoration = 'none';
            }}
          >
            Learn more
          </a>
        </Stack>
        
        {/* Color palette */}
        <Stack horizontal tokens={{ childrenGap: 8 }} wrap>
          {[
            { label: 'Primary', color: theme.palette.themePrimary },
            { label: 'Secondary', color: theme.palette.themeSecondary },
            { label: 'Tertiary', color: theme.palette.themeTertiary },
            { label: 'Accent', color: theme.palette.accent }
          ].map(({ label, color }) => (
            <div
              key={label}
              style={{
                backgroundColor: color,
                color: theme.palette.white,
                padding: '8px 16px',
                borderRadius: theme.effects.roundedCorner2,
                fontSize: theme.fonts.small.fontSize,
                fontWeight: 600
              }}
            >
              {label}
            </div>
          ))}
        </Stack>
        
        {/* State colors */}
        <Stack tokens={{ childrenGap: 8 }}>
          <div
            style={{
              backgroundColor: theme.semanticColors.successBackground,
              color: theme.semanticColors.successText,
              padding: theme.spacing.s1,
              borderRadius: theme.effects.roundedCorner2
            }}
          >
            ✓ Success
          </div>
          
          <div
            style={{
              backgroundColor: theme.semanticColors.warningBackground,
              color: theme.semanticColors.warningText,
              padding: theme.spacing.s1,
              borderRadius: theme.effects.roundedCorner2
            }}
          >
            ⚠ Warning
          </div>
          
          <div
            style={{
              backgroundColor: theme.semanticColors.errorBackground,
              color: theme.semanticColors.errorText,
              padding: theme.spacing.s1,
              borderRadius: theme.effects.roundedCorner2
            }}
          >
            ✗ Error
          </div>
        </Stack>
      </Stack>
    </div>
  );
}
```

**Best Practices**:
✅ Use semantic colors over palette colors
✅ Check for undefined during initial render
✅ Use theme.isInverted for dark mode
✅ Apply theme colors to all custom elements
✅ Use theme.effects for borders/shadows
✅ Use theme.spacing for margins/padding
✅ Use theme.fonts for typography
✅ Combine with Fluent UI components
✅ Test in both light and dark themes
✅ Use semanticColors for state colors

❌ Don't hardcode colors
❌ Don't forget undefined handling
❌ Don't use palette colors directly
❌ Don't assume theme won't change
❌ Don't cache theme values
❌ Don't use inline styles without tokens
❌ Don't forget hover/focus states
❌ Don't mix Fluent 8 and 9 themes
❌ Don't use CSS custom properties
❌ Don't override theme manually

---

#### `useSPFxFluent9ThemeInfo()`
**Purpose**: Fluent UI 9 theme with automatic Teams/SharePoint detection and conversion  
**Returns**: `SPFxFluent9ThemeInfo`  
**Use Case**: Fluent UI 9 apps, FluentProvider integration, automatic theme switching, Teams theming

**Description:**  
Automatically detects the execution context and provides the appropriate Fluent UI 9 theme. In Microsoft Teams, returns native Teams themes (light/dark/highContrast). In SharePoint, converts SPFx theme (v8) to Fluent UI 9 theme using `createV9Theme()`. Uses memoization to avoid expensive theme conversions on every render. Theme updates are automatically handled via SPFxProvider's theme subscription.

**Return Type:**
```typescript
interface SPFxFluent9ThemeInfo {
  readonly theme: Theme;           // Fluent UI 9 theme object (ready for FluentProvider)
  readonly isTeams: boolean;       // Whether running in Microsoft Teams
  readonly teamsTheme?: string;    // Teams theme name ('default', 'dark', 'highContrast')
}
```

**Priority Order:**
1. **Teams native themes** (if in Teams context):
   - `teamsLightTheme` (default)
   - `teamsDarkTheme` (dark)
   - `teamsHighContrastTheme` (highContrast)
2. **SPFx theme converted to Fluent UI 9** using `createV9Theme()` from `@fluentui/react-migration-v8-v9`
3. **Default `webLightTheme`** as fallback

**Key Features:**
- Automatic context detection (Teams vs SharePoint)
- Native Teams theme support for better Teams integration
- SPFx v8 to Fluent UI 9 theme conversion via migration helper
- Memoized theme object for performance (no unnecessary re-renders)
- Automatic theme updates when user switches theme
- Zero configuration required
- Supports dark mode, light mode, and high contrast

**Example:**
```typescript
import { FluentProvider } from '@fluentui/react-components';
import { useSPFxFluent9ThemeInfo } from '@apvee/spfx-react-toolkit';

function MyWebPart() {
  const { theme } = useSPFxFluent9ThemeInfo();
  
  return (
    <FluentProvider theme={theme}>
      <MyApp />
    </FluentProvider>
  );
}
```

**Best Practices:**
- ✅ Wrap your entire app/component tree with FluentProvider at the root
- ✅ Call hook once at the root level (theme is memoized)
- ✅ Use Fluent UI 9 design tokens for theme-aware styling
- ✅ Let the hook handle theme detection automatically
- ✅ Combine with `makeStyles` for consistent, performant theming
- ✅ Test with all three Teams themes (default, dark, highContrast)
- ✅ Use theme tokens instead of hardcoded colors
- ✅ Create reusable FluentProvider wrapper for consistency
- ❌ Don't call hook multiple times unnecessarily (causes re-renders)
- ❌ Don't override theme manually unless absolutely needed
- ❌ Don't mix Fluent UI v8 and v9 components/themes
- ❌ Don't hardcode theme-specific colors (use tokens)
- ❌ Don't forget to import `Theme` type from `@fluentui/react-theme`

#### `useSPFxContainerSize()`
**Purpose**: Get reactive container dimensions with Fluent UI 9 aligned breakpoints  
**Returns**: `SPFxContainerSizeInfo`  
**Use Case**: Responsive layouts, adaptive UI based on container space, Fluent UI 9 compatible design

**Description:**  
Automatically tracks container size changes and categorizes into Fluent UI 9 compatible size categories. Based on official Fluent UI 9 responsive breakpoints.

**Breakpoints (Fluent UI 9 aligned):**
- **small**: 320-479px (mobile portrait)
- **medium**: 480-639px (mobile landscape, small tablets)
- **large**: 640-1023px (tablets, single column)
- **xLarge**: 1024-1365px (laptop, desktop standard)
- **xxLarge**: 1366-1919px (large desktop, wide screen)
- **xxxLarge**: ≥1920px (4K, ultra-wide, multi-column)

**Reference:**  
Based on official Fluent UI 9 responsive breakpoints:  
https://developer.microsoft.com/en-us/fluentui#/styles/web/responsive

**Return Type:**
```typescript
interface SPFxContainerSizeInfo {
  readonly size: SPFxContainerSize;  // 'small' | 'medium' | 'large' | 'xLarge' | 'xxLarge' | 'xxxLarge'
  readonly isSmall: boolean;         // 320-479px (mobile portrait)
  readonly isMedium: boolean;        // 480-639px (mobile landscape)
  readonly isLarge: boolean;         // 640-1023px (tablets)
  readonly isXLarge: boolean;        // 1024-1365px (laptop, desktop)
  readonly isXXLarge: boolean;       // 1366-1919px (wide desktop)
  readonly isXXXLarge: boolean;      // ≥1920px (4K, ultra-wide)
  readonly width: number;            // Actual width in pixels
  readonly height: number;           // Actual height in pixels
}
```

**Useful for:**
- Responsive layouts based on actual container space (not viewport)
- Adaptive UI that works in sidebars, columns, or full width
- Fluent UI 9 compatible responsive design
- Making layout decisions based on available space
- WebParts that need to adapt to different column widths

**Example:**
```typescript
function ResponsiveDataGrid({ items }) {
  const { size, isSmall, isMedium, width, height } = useSPFxContainerSize();
  
  // Dynamic column calculation based on size category
  const columns = {
    small: 1,
    medium: 2,
    large: 3,
    xLarge: 3,
    xxLarge: 4,
    xxxLarge: 6
  }[size];
  
  // Conditional rendering for mobile vs desktop
  if (isSmall || isMedium) {
    return (
      <div style={{ padding: '10px' }}>
        <Text variant="small">Container: {width}px × {height}px</Text>
        <StackedMobileLayout items={items} />
      </div>
    );
  }
  
  // Grid layout for larger screens
  return (
    <div style={{ padding: '20px' }}>
      <Text>Container: {width}px × {height}px ({size})</Text>
      <div style={{ 
        display: 'grid', 
        gridTemplateColumns: `repeat(${columns}, 1fr)`,
        gap: '16px',
        marginTop: '16px'
      }}>
        {items.map(item => (
          <Card key={item.id}>
            <CardHeader>{item.title}</CardHeader>
            <CardBody>{item.description}</CardBody>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

**Best Practices:**
- ✅ Use for responsive layouts based on container space (not viewport)
- ✅ Perfect for WebParts that can be placed in different column widths
- ✅ Use boolean helpers (isSmall, isMedium, etc.) for cleaner conditionals
- ✅ Use size category for switch/map-based layout decisions
- ✅ Combine with Fluent UI 9 components for consistent responsive design
- ✅ Test in different SharePoint column layouts (1, 2, 3 columns)
- ✅ Use width/height for precise calculations when needed
- ❌ Don't use viewport breakpoints - use container breakpoints
- ❌ Don't hardcode breakpoints - use the provided categories
- ❌ Don't forget to test on mobile devices and ultra-wide screens

#### `useSPFxContainerInfo()`
**Purpose**: Access container element and its size with automatic tracking  
**Returns**: `SPFxContainerInfo`  
**Use Case**: Responsive layouts, dynamic sizing, breakpoint calculations, canvas dimensions, direct DOM manipulation

**Return Type:**
```typescript
interface SPFxContainerInfo {
  readonly element: HTMLElement | undefined;  // Container DOM element
  readonly size: ContainerSize | undefined;   // { width: number, height: number }
}
```

**Description:**  
Automatically tracks container size changes using ResizeObserver. Updates in real-time when container is resized.

**Useful for:**
- Responsive layouts based on actual container size
- Dynamic content sizing (canvas, charts, images)
- Breakpoint calculations (custom breakpoints)
- Direct DOM manipulation when needed
- Size monitoring and analytics

**Example:**
```typescript
import { useEffect, useRef, useMemo } from 'react';

function ResponsiveChartWidget({ data }) {
  const { size, element } = useSPFxContainerInfo();
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  // Calculate columns based on width with memoization
  const columns = useMemo(() => {
    if (!size) return 1;
    if (size.width < 640) return 1;    // Mobile
    if (size.width < 1024) return 2;   // Tablet
    if (size.width < 1366) return 3;   // Laptop
    return 4;                           // Desktop
  }, [size]);
  
  // Update canvas when size changes
  useEffect(() => {
    if (!canvasRef.current || !size) return;
    
    const ctx = canvasRef.current.getContext('2d');
    if (!ctx) return;
    
    // Clear and redraw chart
    ctx.clearRect(0, 0, size.width, size.height);
    drawChart(ctx, data, size.width, size.height);
  }, [data, size]);
  
  // Direct DOM manipulation when needed
  useEffect(() => {
    if (element) {
      element.style.overflow = 'hidden';
      element.classList.add('chart-container');
    }
  }, [element]);
  
  if (!size) {
    return <Spinner label="Loading..." />;
  }
  
  return (
    <div>
      <Text>Container: {size.width}px × {size.height}px ({columns} columns)</Text>
      <canvas 
        ref={canvasRef}
        width={size.width} 
        height={size.height}
        style={{ width: '100%', height: '100%' }}
      />
    </div>
  );
}
```

**Best Practices:**
```typescript
import { useEffect, useRef } from 'react';

function ChartComponent({ data }) {
  const { size } = useSPFxContainerInfo();
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    if (!canvasRef.current || !size) return;
    
    const ctx = canvasRef.current.getContext('2d');
    if (!ctx) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, size.width, size.height);
    
    // Draw chart based on size
    drawChart(ctx, data, size.width, size.height);
  }, [data, size]);
  
  return (
    <canvas 
      ref={canvasRef}
      width={size?.width || 0} 
      height={size?.height || 0}
      style={{ width: '100%', height: '100%' }}
    />
  );
}
```

**Best Practices:**
- ✅ Use `size` for responsive layouts instead of hardcoded breakpoints
- ✅ Use `useMemo` for expensive calculations based on size
- ✅ Check if `size` and `element` are defined before using them
- ✅ Use for canvas/chart dimensions to ensure proper rendering
- ✅ Prefer `useSPFxContainerSize()` for simpler breakpoint detection
- ❌ Don't perform heavy calculations in render without memoization
- ❌ Don't manipulate DOM directly unless absolutely necessary
- ❌ Don't forget null checks for `element` and `size`

### Storage

### `useSPFxLocalStorage<T>(key, defaultValue)`
**Purpose**: Instance-scoped localStorage for persistent data across sessions  
**Returns**: `SPFxStorageHook<T>`
```typescript
interface SPFxStorageHook<T> {
  readonly value: T;                                              // Current value from storage
  readonly setValue: (value: T | ((prev: T) => T)) => void;     // Set new value (updater supported)
  readonly remove: () => void;                                    // Remove from storage, reset to default
}
```

**Parameters:**
- `key: string` - Storage key (auto-prefixed with "spfx:{instanceId}:")
- `defaultValue: T` - Default value if not in storage

**Use Cases**: User preferences, view settings, form drafts, long-lived cache, feature flags, recently viewed, favorites, configuration

**Key Features**:
- Persistent storage (survives page reloads and browser restarts)
- Automatic instance scoping (keys prefixed with instance ID)
- Type-safe with generics
- Updater function support (like React setState)
- Jotai integration (atomWithStorage)
- Automatic JSON serialization/deserialization
- Remove support (clear and reset to default)
- SSR safe (checks localStorage availability)

**Implementation Details**:
- Uses useSPFxInstanceInfo() to get instance ID
- Scoped key format: "spfx:{instanceId}:{key}"
- Creates atomWithStorage with useMemo (avoids recreation)
- Uses useAtom for reactive state
- remove() sets to default and removes from localStorage
- Data persists across sessions

**Example - User Preferences:**
```typescript
interface UserPreferences {
  viewMode: 'grid' | 'list' | 'compact';
  itemsPerPage: number;
  showImages: boolean;
  sortBy: string;
}

function PreferencesPanel() {
  const { value: prefs, setValue: setPrefs, remove } = 
    useSPFxLocalStorage<UserPreferences>('user-prefs', {
      viewMode: 'grid',
      itemsPerPage: 20,
      showImages: true,
      sortBy: 'title'
    });
  
  return (
    <Stack tokens={{ childrenGap: 15 }}>
      <ChoiceGroup
        selectedKey={prefs.viewMode}
        options={[
          { key: 'grid', text: 'Grid' },
          { key: 'list', text: 'List' },
          { key: 'compact', text: 'Compact' }
        ]}
        onChange={(_, option) => 
          setPrefs(prev => ({ ...prev, viewMode: option?.key as any }))
        }
      />
      
      <SpinButton
        label="Items per page"
        value={prefs.itemsPerPage.toString()}
        min={10}
        max={100}
        step={10}
        onIncrement={val => 
          setPrefs(prev => ({ ...prev, itemsPerPage: parseInt(val) + 10 }))
        }
      />
      
      <Toggle
        label="Show Images"
        checked={prefs.showImages}
        onChange={(_, checked) => 
          setPrefs(prev => ({ ...prev, showImages: checked ?? true }))
        }
      />
      
      <DefaultButton text="Reset" onClick={remove} />
    </Stack>
  );
}
```

**Best Practices**:
✅ Use generic type parameter for type safety
✅ Provide meaningful default values
✅ Use updater function for partial updates
✅ Use remove() to clear and reset
✅ Use for data that should persist
✅ Use descriptive keys
✅ Validate stored data on read
✅ Handle storage quota exceeded
✅ Use for preferences, view settings, drafts
✅ Consider migration strategy for changes

❌ Don't store sensitive data
❌ Don't store large datasets
❌ Don't use for temporary UI state
❌ Don't forget data persists
❌ Don't assume localStorage available
❌ Don't store non-serializable objects
❌ Don't use same key for different types
❌ Don't store frequently changing data
❌ Don't bypass setValue/remove
❌ Don't forget instance scoping

---

### `useSPFxSessionStorage<T>(key, defaultValue)`
**Purpose**: Instance-scoped sessionStorage for temporary data (current tab/session only)  
**Returns**: `SPFxStorageHook<T>`
```typescript
interface SPFxStorageHook<T> {
  readonly value: T;                                              // Current value from storage
  readonly setValue: (value: T | ((prev: T) => T)) => void;     // Set new value (updater supported)
  readonly remove: () => void;                                    // Remove from storage, reset to default
}
```

**Parameters:**
- `key: string` - Storage key (auto-prefixed with "spfx:{instanceId}:")
- `defaultValue: T` - Default value if not in storage

**Use Cases**: Wizard state, session cache, tab-specific settings, temporary filters, draft mode, pagination state, expanded/collapsed state, temporary selections

**Key Features**:
- Session-scoped (cleared when tab closes)
- Automatic instance scoping (keys prefixed with instance ID)
- Type-safe with generics
- Updater function support (like React setState)
- Jotai integration (atomWithStorage with custom sessionStorage)
- Automatic JSON serialization/deserialization
- Remove support (clear and reset to default)
- SSR safe (checks sessionStorage availability)

**Implementation Details**:
- Uses useSPFxInstanceInfo() to get instance ID
- Scoped key format: "spfx:{instanceId}:{key}"
- Creates atomWithStorage with custom sessionStorage implementation
- Uses useAtom for reactive state
- remove() sets to default and removes from sessionStorage
- Data cleared when tab/session ends

**Example - Wizard State:**
```typescript
interface WizardState {
  currentStep: number;
  completedSteps: number[];
  formData: {
    name?: string;
    email?: string;
    department?: string;
  };
}

function OnboardingWizard() {
  const { value: wizard, setValue: setWizard, remove } = 
    useSPFxSessionStorage<WizardState>('wizard-state', {
      currentStep: 1,
      completedSteps: [],
      formData: {}
    });
  
  const totalSteps = 4;
  
  const goToStep = (step: number) => {
    setWizard(prev => ({ ...prev, currentStep: step }));
  };
  
  const markStepComplete = () => {
    setWizard(prev => ({
      ...prev,
      completedSteps: [...prev.completedSteps, prev.currentStep]
    }));
  };
  
  const updateFormData = (field: string, value: any) => {
    setWizard(prev => ({
      ...prev,
      formData: { ...prev.formData, [field]: value }
    }));
  };
  
  const resetWizard = () => remove();
  
  return (
    <Stack tokens={{ childrenGap: 20 }}>
      <ProgressIndicator
        label={`Step ${wizard.currentStep} of ${totalSteps}`}
        percentComplete={wizard.currentStep / totalSteps}
      />
      
      {wizard.currentStep === 1 && (
        <Stack tokens={{ childrenGap: 10 }}>
          <TextField
            label="Name"
            value={wizard.formData.name || ''}
            onChange={(_, val) => updateFormData('name', val)}
          />
          <TextField
            label="Email"
            value={wizard.formData.email || ''}
            onChange={(_, val) => updateFormData('email', val)}
          />
        </Stack>
      )}
      
      <Stack horizontal tokens={{ childrenGap: 10 }}>
        <PrimaryButton
          text="Next"
          onClick={() => {
            markStepComplete();
            if (wizard.currentStep < totalSteps) goToStep(wizard.currentStep + 1);
          }}
        />
        <DefaultButton text="Back" onClick={() => goToStep(wizard.currentStep - 1)} />
        <DefaultButton text="Reset" onClick={resetWizard} />
      </Stack>
      
      <MessageBar messageBarType={MessageBarType.info}>
        Progress saved to sessionStorage. Data cleared when tab closes.
      </MessageBar>
    </Stack>
  );
}
```

**Best Practices**:
✅ Use generic type parameter for type safety
✅ Provide meaningful default values
✅ Use updater function for partial updates
✅ Use remove() to clear and reset
✅ Use for data that should NOT persist
✅ Use for wizard/multi-step forms
✅ Use for temporary filters and pagination
✅ Inform users data is session-specific
✅ Validate stored data on read
✅ Consider localStorage if data should persist

❌ Don't store sensitive data
❌ Don't assume data persists across tabs
❌ Don't use for long-term storage
❌ Don't store large datasets
❌ Don't forget data cleared on tab close
❌ Don't store non-serializable objects
❌ Don't assume sessionStorage available
❌ Don't use for cross-tab communication
❌ Don't bypass setValue/remove
❌ Don't forget instance scoping

---

### Performance & Diagnostics

#### `useSPFxPerformance()`
**Purpose**: Performance measurement API with automatic SPFx context integration  
**Returns**: `SPFxPerformanceInfo`  
**Use Case**: Performance profiling, bottleneck detection, real-world monitoring, Application Insights integration, custom dashboards

**Description:**  
Provides access to the Performance API for measuring code execution time with automatic SPFx context enrichment (instanceId, correlationId, host). Supports three measurement methods: mark() for creating named marks, measure() for calculating duration between marks, and time() for wrapping async operations with automatic timing.

**Return Type:**
```typescript
interface SPFxPerformanceInfo {
  readonly mark: (name: string) => void;
  readonly measure: (name: string, startMark: string, endMark?: string) => SPFxPerfResult;
  readonly time: <T>(name: string, fn: () => Promise<T> | T) => Promise<SPFxPerfResult<T>>;
}

interface SPFxPerfResult<T = unknown> {
  readonly name: string;                    // Measurement name
  readonly durationMs: number;              // Duration in milliseconds
  readonly result?: T;                      // Optional result from timed operation
  readonly instanceId: string;              // SPFx instance ID
  readonly host: string;                    // Host kind (WebPart, Extension)
  readonly correlationId: string | undefined; // Correlation ID for tracking
}
```

**Key Features:**
- Native Performance API integration (performance.mark, performance.measure)
- Automatic SPFx context enrichment (instanceId, correlationId, host)
- Type-safe with TypeScript generics
- Error handling (swallows Performance API errors)
- Three measurement patterns (mark, measure, time)
- Integration-ready for Application Insights
- Zero-cost when Performance API is not available (graceful fallback)

**Measurement Patterns:**

1. **mark()** - Create named marks:
```typescript
mark('data-fetch-start');
// ... operation ...
mark('data-fetch-end');
```

2. **measure()** - Calculate duration between marks:
```typescript
mark('start');
// ... operation ...
const result = measure('operation', 'start');
console.log(`Duration: ${result.durationMs}ms`);
```

3. **time()** - Wrap async operations (recommended):
```typescript
const result = await time('fetch-data', async () => {
  const response = await fetch('/api/data');
  return response.json();
});
console.log(`Fetch took ${result.durationMs}ms`);
const data = result.result;
```

**Use Cases:**
- **Performance Profiling**: Measure component render times, data fetching
- **Bottleneck Detection**: Identify slow operations
- **Real-World Monitoring**: Track actual user-facing performance
- **Application Insights Integration**: Send metrics to Azure Monitor
- **Custom Dashboards**: Build performance monitoring dashboards
- **A/B Testing**: Compare performance of different implementations
- **Regression Detection**: Track performance changes over time

**Example - Comprehensive performance monitoring:**
```typescript
import { useSPFxPerformance, useSPFxLogger } from '@apvee/spfx-react-toolkit';

interface PerformanceMetrics {
  fetchTime: number;
  renderTime: number;
  totalTime: number;
}

function PerformanceMonitoredComponent() {
  const { time, mark, measure } = useSPFxPerformance();
  const logger = useSPFxLogger();
  const [data, setData] = useState<any[]>([]);
  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  
  const loadData = async () => {
    setIsLoading(true);
    mark('load-start');
    
    try {
      // Time the data fetch operation
      const fetchResult = await time('data-fetch', async () => {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        if (!response.ok) throw new Error('Fetch failed');
        return response.json();
      });
      
      logger.info('Data fetch completed', {
        durationMs: fetchResult.durationMs,
        itemCount: fetchResult.result.length
      });
      
      // Time the data processing
      const processResult = await time('data-process', async () => {
        return fetchResult.result
          .slice(0, 20)
          .map((item: any) => ({
            ...item,
            processed: true,
            timestamp: Date.now()
          }));
      });
      
      setData(processResult.result);
      
      // Measure total time
      const totalResult = measure('total-load', 'load-start');
      
      // Calculate metrics
      const performanceMetrics: PerformanceMetrics = {
        fetchTime: fetchResult.durationMs,
        renderTime: processResult.durationMs,
        totalTime: totalResult.durationMs
      };
      
      setMetrics(performanceMetrics);
      
      // Log performance metrics
      logger.info('Performance metrics collected', {
        ...performanceMetrics,
        correlationId: totalResult.correlationId
      });
      
      // Send to Application Insights (example)
      if (window.appInsights) {
        window.appInsights.trackMetric({
          name: 'DataLoadTime',
          average: totalResult.durationMs,
          properties: {
            instanceId: totalResult.instanceId,
            host: totalResult.host,
            correlationId: totalResult.correlationId
          }
        });
      }
      
    } catch (error) {
      logger.error('Data load failed', {
        error,
        errorMessage: (error as Error).message
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  useEffect(() => {
    loadData();
  }, []);
  
  if (isLoading) return <Spinner label="Loading data..." />;
  
  return (
    <div style={{ padding: '16px' }}>
      <h2>Performance Monitored Component</h2>
      
      {metrics && (
        <MessageBar messageBarType={MessageBarType.success}>
          <strong>Performance Metrics:</strong>
          <ul style={{ margin: '8px 0', paddingLeft: '20px' }}>
            <li>Data Fetch: {metrics.fetchTime.toFixed(2)}ms</li>
            <li>Data Processing: {metrics.renderTime.toFixed(2)}ms</li>
            <li>Total Load Time: {metrics.totalTime.toFixed(2)}ms</li>
          </ul>
          {metrics.totalTime > 1000 && (
            <div style={{ color: '#a4262c', marginTop: '8px' }}>
              ⚠️ Warning: Load time exceeds 1 second.
            </div>
          )}
        </MessageBar>
      )}
      
      <div style={{ marginTop: '16px' }}>
        <button onClick={loadData}>Reload Data</button>
        <h3>Data Items ({data.length})</h3>
        <ul>
          {data.map((item) => (
            <li key={item.id}>
              <strong>{item.title}</strong>
              <div style={{ fontSize: '12px', color: '#666' }}>
                {item.body.substring(0, 100)}...
              </div>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```

**Best Practices:**
- ✅ Use time() for simple async operation timing (recommended)
- ✅ Use mark()/measure() for granular control
- ✅ Include correlationId in logs for distributed tracing
- ✅ Send performance metrics to Application Insights or monitoring service
- ✅ Set performance budgets and alert on slow operations (> 1000ms)
- ✅ Measure both successful and failed operations
- ✅ Track performance over time to detect regressions
- ✅ Use meaningful measurement names (descriptive, kebab-case)
- ✅ Combine with useSPFxLogger for comprehensive monitoring
- ❌ Don't measure trivial operations (adds overhead)
- ❌ Don't create too many marks (can impact performance)
- ❌ Don't block UI with synchronous calls
- ❌ Don't ignore performance results (analyze and act)
- ❌ Don't forget Performance API might be unavailable (hook handles this)

#### `useSPFxLogger(handler?)`
**Purpose**: Structured logging with automatic SPFx context enrichment  
**Returns**: `SPFxLoggerInfo`  
**Use Case**: Diagnostic logging, error tracking, performance monitoring, Application Insights integration, support troubleshooting

**Description:**  
Provides structured logging methods that automatically include comprehensive SPFx context: instance ID, host kind, current user, site/web URLs, correlation ID, and timestamp. By default logs to console with formatted output, but accepts custom handler for integration with Application Insights, Log Analytics, or other logging services.

**Return Type:**
```typescript
interface SPFxLoggerInfo {
  readonly debug: (message: string, extra?: Record<string, unknown>) => void;
  readonly info: (message: string, extra?: Record<string, unknown>) => void;
  readonly warn: (message: string, extra?: Record<string, unknown>) => void;
  readonly error: (message: string, extra?: Record<string, unknown>) => void;
}

interface LogEntry {
  readonly level: 'debug' | 'info' | 'warn' | 'error';
  readonly message: string;
  readonly ts: string;                                   // ISO 8601 timestamp
  readonly instanceId: string;                           // SPFx instance ID
  readonly host: string;                                 // Host kind (WebPart, Extension)
  readonly user: string;                                 // Current user (displayName + loginName)
  readonly siteUrl: string | undefined;                  // Site collection URL
  readonly webUrl: string | undefined;                   // Web URL
  readonly correlationId: string | undefined;            // Correlation ID
  readonly webPartTag?: string;                          // WebPart tag (WebPart contexts only)
  readonly extra?: Record<string, unknown>;              // Custom metadata
}
```

**Key Features:**
- Automatic context enrichment (instance, user, site, correlation ID)
- Default console output with formatted timestamps and context
- Custom handler support for external logging services
- WebPart tag extraction (WebPart contexts only, for better readability)
- Type-safe extra metadata via Record<string, unknown>
- ISO 8601 timestamps for consistency
- Appropriate console methods (console.log for debug, console.warn, console.error)

**Default Console Output Format:**
```
[LEVEL] ISO_TIMESTAMP HOST/INSTANCE_OR_TAG – MESSAGE { extra }
```

**Use Cases:**
- **Diagnostic Logging**: Track user actions and component lifecycle events
- **Error Tracking**: Capture errors with full context for debugging
- **Performance Monitoring**: Log timing metrics and performance data
- **User Activity Tracking**: Monitor user interactions and behaviors
- **Support Troubleshooting**: Include correlation IDs in support tickets
- **Application Insights Integration**: Forward logs to Azure Monitor
- **Custom Logging Services**: Send logs to third-party services

**Example - Application Insights integration:**
```typescript
import { useSPFxLogger } from '@apvee/spfx-react-toolkit';
import { ApplicationInsights } from '@microsoft/applicationinsights-web';

// Initialize Application Insights
const appInsights = new ApplicationInsights({
  config: {
    instrumentationKey: 'YOUR-INSTRUMENTATION-KEY',
    enableAutoRouteTracking: true
  }
});
appInsights.loadAppInsights();

// Custom handler for Application Insights
const appInsightsHandler = (entry: LogEntry) => {
  // Map log levels to Application Insights severity
  const severityMap = {
    debug: 0,  // Verbose
    info: 1,   // Information
    warn: 2,   // Warning
    error: 3   // Error
  };
  
  appInsights.trackTrace({
    message: entry.message,
    severityLevel: severityMap[entry.level],
    properties: {
      instanceId: entry.instanceId,
      host: entry.host,
      user: entry.user,
      siteUrl: entry.siteUrl,
      webUrl: entry.webUrl,
      correlationId: entry.correlationId,
      webPartTag: entry.webPartTag,
      timestamp: entry.ts,
      ...entry.extra
    }
  });
  
  // Also track errors separately for better alerting
  if (entry.level === 'error' && entry.extra?.error) {
    appInsights.trackException({
      exception: entry.extra.error as Error,
      properties: {
        instanceId: entry.instanceId,
        correlationId: entry.correlationId,
        ...entry.extra
      }
    });
  }
};

function MonitoredComponent() {
  const logger = useSPFxLogger(appInsightsHandler);
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    logger.info('Button clicked', {
      buttonId: 'increment',
      previousCount: count,
      timestamp: Date.now()
    });
    setCount(count + 1);
  };
  
  const handleError = async () => {
    try {
      await fetch('/api/data');
    } catch (error) {
      logger.error('API request failed', {
        error,
        errorMessage: (error as Error).message,
        stack: (error as Error).stack,
        endpoint: '/api/data',
        timestamp: Date.now()
      });
    }
  };
  
  const handleWarning = () => {
    logger.warn('Deprecated feature used', {
      feature: 'legacyAPI',
      migrationGuide: 'https://docs.example.com/migration'
    });
  };
  
  // Debug logging for development
  logger.debug('Component rendered', {
    count,
    renderTime: performance.now()
  });
  
  return (
    <div>
      <h3>Monitored Component</h3>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
      <button onClick={handleError}>Trigger Error</button>
      <button onClick={handleWarning}>Show Warning</button>
    </div>
  );
}
```

**Best Practices:**
- ✅ Use custom handler for production logging (Application Insights, Log Analytics)
- ✅ Include correlation IDs in all logs for distributed tracing
- ✅ Log errors with full context (error message, stack trace, extra metadata)
- ✅ Use appropriate log levels (debug for dev, info for user actions, error for failures)
- ✅ Include timestamp in extra metadata for time-based analysis
- ✅ Track user actions with meaningful metadata (button IDs, action types)
- ✅ Use structured metadata instead of string concatenation
- ✅ Implement error boundaries that use logger for unhandled errors
- ✅ Monitor log volume and implement sampling for high-traffic scenarios
- ✅ Use useMemo or singleton pattern for custom handler to avoid recreation
- ❌ Don't log sensitive data (passwords, tokens, PII) in extra metadata
- ❌ Don't log in tight loops or high-frequency events without throttling
- ❌ Don't rely solely on console logs in production (use custom handler)
- ❌ Don't ignore log levels (use appropriate level for each scenario)
- ❌ Don't log large objects without truncation (can cause memory issues)

#### `useSPFxCorrelationInfo()`
**Purpose**: Access correlation ID and tenant ID for distributed tracing and diagnostics  
**Returns**: `SPFxCorrelationInfo`  
**Use Case**: Distributed tracing, log correlation, support tickets, security auditing, performance monitoring

**Description:**  
Provides diagnostic IDs for tracking and monitoring:
- **Correlation ID**: Tracks requests across SPFx → SharePoint → Microsoft Graph
- **Tenant ID**: Azure AD tenant identifier

These IDs are essential for:
- Distributed tracing across Microsoft services
- Log correlation and aggregation
- Support tickets with full context
- Diagnostic troubleshooting
- Security auditing
- Performance monitoring

**Return Type:**
```typescript
interface SPFxCorrelationInfo {
  readonly correlationId: string | undefined;  // Correlation ID for tracking requests
  readonly tenantId: string | undefined;       // Azure AD Tenant ID
}
```

**Example - Application Insights integration:**
```typescript
import { ApplicationInsights } from '@microsoft/applicationinsights-web';

function MonitoredComponent() {
  const { correlationId, tenantId } = useSPFxCorrelationInfo();
  const appInsights = new ApplicationInsights({ 
    config: { 
      instrumentationKey: 'YOUR-KEY',
      enableAutoRouteTracking: true 
    } 
  });
  appInsights.loadAppInsights();
  
  const trackEvent = (eventName: string, properties?: any) => {
    appInsights.trackEvent({
      name: eventName,
      properties: {
        ...properties,
        correlationId,
        tenantId,
        timestamp: new Date().toISOString()
      }
    });
  };
  
  const trackException = (error: Error) => {
    appInsights.trackException({
      exception: error,
      properties: {
        correlationId,
        tenantId
      }
    });
  };
  
  const handleAction = () => {
    try {
      // Perform action
      trackEvent('UserAction', { action: 'ButtonClick' });
    } catch (error) {
      trackException(error as Error);
    }
  };
  
  return <button onClick={handleAction}>Track Action</button>;
}
```

**Best Practices:**
- ✅ Include in all structured logs and error tracking
- ✅ Add to API request headers for distributed tracing
- ✅ Include in Application Insights custom events
- ✅ Attach to support tickets for faster resolution
- ✅ Use for log correlation across multiple services
- ✅ Store with error reports for debugging
- ✅ Include in performance monitoring data
- ❌ Don't expose correlation IDs to end users (internal use)
- ❌ Don't use as authentication tokens (not secure)
- ❌ Don't assume they're always available (can be undefined)

### Permissions & Security

#### `useSPFxPermissions()`
**Purpose**: SharePoint permissions checking at multiple scopes (site, web, list)  
**Returns**: `SPFxPermissionsInfo`
```typescript
interface SPFxPermissionsInfo {
  readonly sitePermissions: SPPermission | undefined;      // Site collection permissions
  readonly webPermissions: SPPermission | undefined;       // Web permissions
  readonly listPermissions: SPPermission | undefined;      // List permissions (if in list context)
  readonly hasWebPermission: (permission: SPPermission) => boolean;
  readonly hasSitePermission: (permission: SPPermission) => boolean;
  readonly hasListPermission: (permission: SPPermission) => boolean;
}
```

**Use Cases**: Security trimming, conditional UI rendering, feature availability, authorization checks, administrative panels, permission auditing

**Key Features**:
- Multi-scope permission access (site collection, web, list)
- SPPermission enum integration
- Helper methods for permission validation
- Null-safe permission checking
- Context-aware list permissions
- Memoized checking functions

**Common SPPermission Values**:
- `SPPermission.manageWeb` - Manage web settings
- `SPPermission.addListItems` - Add items
- `SPPermission.editListItems` - Edit items
- `SPPermission.deleteListItems` - Delete items
- `SPPermission.viewListItems` - View items
- `SPPermission.managePermissions` - Manage permissions
- `SPPermission.manageLists` - Create/delete lists

**Implementation Details**:
- Extracts permissions from PageContext at site/web/list levels
- Returns undefined for permissions when not available
- Helper methods return false for undefined permissions
- List permissions only available in list context
- Uses useCallback for performance optimization

**Example**:
```typescript
import { SPPermission } from '@microsoft/sp-page-context';

function SecureAdminPanel() {
  const { 
    sitePermissions,
    hasWebPermission, 
    hasSitePermission,
    hasListPermission 
  } = useSPFxPermissions();
  
  // Check permissions at different scopes
  const canManageWeb = hasWebPermission(SPPermission.manageWeb);
  const canManageSite = hasSitePermission(SPPermission.manageWeb);
  const canAddItems = hasListPermission(SPPermission.addListItems);
  const canEditItems = hasListPermission(SPPermission.editListItems);
  const canDeleteItems = hasListPermission(SPPermission.deleteListItems);
  
  if (!sitePermissions) {
    return <div>Loading permissions...</div>;
  }
  
  return (
    <div>
      <h2>Admin Panel</h2>
      
      {/* Site-level controls */}
      {canManageSite && (
        <section>
          <h3>Site Administration</h3>
          <button>Manage Site Settings</button>
          <button>Configure Features</button>
        </section>
      )}
      
      {/* Web-level controls */}
      {canManageWeb && (
        <section>
          <h3>Web Administration</h3>
          <button>Manage Web Settings</button>
          <button>Edit Navigation</button>
        </section>
      )}
      
      {/* List-level controls */}
      <section>
        <h3>List Operations</h3>
        {canAddItems && <button>Add New Item</button>}
        {canEditItems && <button>Edit Items</button>}
        {canDeleteItems && <button>Delete Items</button>}
        {!canAddItems && !canEditItems && !canDeleteItems && (
          <p>Read-only access</p>
        )}
      </section>
      
      {/* Permission status */}
      {!canManageWeb && !canManageSite && (
        <div style={{ color: 'orange' }}>
          ⚠️ You have limited permissions
        </div>
      )}
    </div>
  );
}
```

**Best Practices**:
✅ Use helper methods (`hasWebPermission`, etc.) instead of direct `SPPermission.hasPermission()` calls
✅ Check for undefined permissions before sensitive operations
✅ Implement multi-level security checks (site → web → list)
✅ Provide user feedback when actions are blocked
✅ Use specific permission checks rather than broad administrator checks
✅ Cache permission check results within component renders
✅ Use for security trimming in navigation and menus
✅ Validate permissions on both client and server side
✅ Test with different permission levels
✅ Consider permission inheritance for list permissions

❌ Don't rely solely on client-side checks for security enforcement
❌ Don't assume permissions are available immediately
❌ Don't perform checks in tight loops
❌ Don't use as only authorization mechanism for critical operations
❌ Don't hardcode permission logic
❌ Don't check list permissions outside list context
❌ Don't forget permissions can change during session
❌ Don't reveal permission structure to unauthorized users
❌ Don't use overly broad permission checks
❌ Don't bypass permission checks for convenience

### `useSPFxServiceScope()`
**Purpose**: Access SPFx ServiceScope for advanced dependency injection and service consumption  
**Returns**: `SPFxServiceScopeInfo`
```typescript
interface SPFxServiceScopeInfo {
  readonly serviceScope: ServiceScope | undefined;                     // Native ServiceScope instance
  readonly consume: <T>(serviceKey: ServiceKey<T>) => T;              // Type-safe service consumption
}
```

**Use Cases**: Custom service consumption, EventAggregator access, advanced service architecture, service mocking, cross-component communication, decoupled components, built-in service access

**Key Features**:
- Type-safe service consumption with generic consume() method
- Access to built-in SPFx services (EventAggregator, HttpClient, etc.)
- Custom service support for registered services in solution
- Service lifecycle and isolation managed by SPFx
- Lazy service consumption (instantiated only when consumed)
- Error handling (consume() throws if ServiceScope unavailable)
- Stable references from useCallback

**Implementation Details**:
- Extracts serviceScope from spfxContext
- consume() wraps serviceScope.consume() with type safety
- Throws error if serviceScope is undefined
- Most common services have dedicated hooks (prefer those)
- Use primarily for custom services or advanced scenarios

**Example**:
```typescript
import { ServiceKey } from '@microsoft/sp-core-library';
import { IEventAggregator } from '@microsoft/sp-core-library';

interface IDataService {
  fetchData(): Promise<any[]>;
  saveData(data: any): Promise<void>;
}

const DataServiceKey = ServiceKey.create<IDataService>(
  'my-solution:IDataService',
  IDataService
);

function MyComponent() {
  const { consume, serviceScope } = useSPFxServiceScope();
  const [data, setData] = React.useState<any[]>([]);
  const [events, setEvents] = React.useState<string[]>([]);
  
  // Consume custom service
  const dataService = React.useMemo(
    () => consume<IDataService>(DataServiceKey),
    [consume]
  );
  
  // Fetch data
  React.useEffect(() => {
    dataService.fetchData().then(setData);
  }, [dataService]);
  
  // Subscribe to events
  React.useEffect(() => {
    if (!serviceScope) return;
    
    const eventAggregator = serviceScope.consume(
      ServiceKey.create<IEventAggregator>('EventAggregator', IEventAggregator)
    );
    
    const subscription = eventAggregator.subscribe('DataUpdated', (args) => {
      setEvents(prev => [...prev, `Event: ${JSON.stringify(args)}`]);
    });
    
    return () => subscription.dispose();
  }, [serviceScope]);
  
  const handleSave = async () => {
    await dataService.saveData({ name: 'New Item' });
    
    if (serviceScope) {
      const eventAggregator = serviceScope.consume(
        ServiceKey.create<IEventAggregator>('EventAggregator', IEventAggregator)
      );
      eventAggregator.raise('DataUpdated', { timestamp: Date.now() });
    }
  };
  
  return (
    <Stack tokens={{ childrenGap: 15 }}>
      <DetailsList items={data} columns={[{ key: 'name', name: 'Name', fieldName: 'name' }]} />
      <PrimaryButton text="Save" onClick={handleSave} />
      {events.map((e, i) => <Text key={i}>{e}</Text>)}
    </Stack>
  );
}
```

**Best Practices**:
✅ Use dedicated hooks for common services (useSPFxHttpClient, etc.)
✅ Memoize consumed services with React.useMemo
✅ Dispose subscriptions/resources in cleanup
✅ Use ServiceKey.create() with unique identifiers
✅ Define service interfaces/keys in separate files
✅ Handle serviceScope being undefined
✅ Use services for cross-component communication
✅ Implement service interfaces for testability
✅ Register custom services in onInit()
✅ Use consume() helper for type safety

❌ Don't consume services in render
❌ Don't create ServiceKeys on every render
❌ Don't forget to dispose resources
❌ Don't use for component state
❌ Don't bypass dedicated hooks
❌ Don't store services in React state
❌ Don't consume conditionally
❌ Don't forget error handling
❌ Don't create circular dependencies
❌ Don't use for simple data sharing

---

### HTTP Clients

#### `useSPFxHttpClient()`
**Purpose**: Generic HTTP client with automatic state management for external APIs and webhooks  
**Returns**: `SPFxHttpClientInfo`  
**Use Case**: External API integration, webhooks, CORS-enabled REST APIs, public data sources, third-party services

**Description:**  
Provides native HttpClient for generic HTTP requests to external APIs, webhooks, or any non-SharePoint endpoints. For SharePoint REST API calls, use `useSPFxSPHttpClient` instead.

Offers two usage patterns:
1. **invoke()** - Automatic state management (loading + error tracking)
2. **client** - Direct access for full control

**Return Type:**
```typescript
interface SPFxHttpClientInfo {
  readonly client: HttpClient;                                           // Always available after Provider init
  readonly invoke: <T>(fn: (client: HttpClient) => Promise<T>) => Promise<T>;  // Automatic state management
  readonly isLoading: boolean;                                          // Loading state during invoke() calls
  readonly error: Error | undefined;                                    // Last error from invoke() calls
  readonly clearError: () => void;                                      // Clear current error
}
```

**Key Features:**
- Two usage patterns: invoke() (automatic state) or client (direct access)
- Built-in loading and error state management with invoke()
- Type-safe with TypeScript generics
- Always available (non-undefined) after Provider initialization
- Lazy service consumption with caching for optimal performance
- Does not track state for direct client usage (only invoke())

**Key Differences from SPHttpClient:**
- **HttpClient**: Generic HTTP calls to any URL (public APIs, webhooks, external services)
- **SPHttpClient**: SharePoint-specific REST API calls with integrated authentication

Use HttpClient for external APIs, SPHttpClient for SharePoint `/_api/` endpoints.

**Requirements:**
- SPFx ServiceScope with HttpClient service
- Network access to target endpoints
- CORS configured on external APIs (if applicable)

**Example - Public API with automatic state management:**
```typescript
import { useSPFxHttpClient } from '@apvee/spfx-react-toolkit';
import { HttpClient } from '@microsoft/sp-http';

function WeatherWidget() {
  const { invoke, isLoading, error, clearError } = useSPFxHttpClient();
  const [weather, setWeather] = useState<any>(null);
  
  const loadWeather = () => {
    invoke(client =>
      client.get(
        'https://api.openweathermap.org/data/2.5/weather?q=London&appid=YOUR_KEY',
        HttpClient.configurations.v1
      ).then(res => res.json())
    ).then(data => setWeather(data));
  };
  
  useEffect(() => { loadWeather(); }, []);
  
  if (isLoading) return <Spinner label="Loading weather..." />;
  if (error) return (
    <MessageBar messageBarType={MessageBarType.error}>
      {error.message}
      <Link onClick={() => { clearError(); loadWeather(); }}>Retry</Link>
    </MessageBar>
  );
  
  return (
    <div>
      <h3>Weather in London</h3>
      <p>Temperature: {weather?.main?.temp}°K</p>
      <p>Conditions: {weather?.weather?.[0]?.description}</p>
    </div>
  );
}
```

**Best Practices:**
- ✅ Use `invoke()` for automatic loading and error state management
- ✅ Use `client` directly for advanced scenarios requiring full control
- ✅ Handle CORS issues by configuring target API or using proxy
- ✅ Store API keys securely (never hardcode in client code)
- ✅ Implement retry logic for failed requests with `clearError()`
- ✅ Use `clearError()` before retrying to reset error state
- ✅ Validate response status before parsing JSON
- ✅ Set appropriate headers (Accept, Content-Type, API keys)
- ✅ Handle rate limiting and implement exponential backoff
- ✅ Cache responses when appropriate to reduce API calls
- ✅ Implement timeout handling for slow networks
- ❌ Don't use for SharePoint REST API (use `useSPFxSPHttpClient` instead)
- ❌ Don't ignore CORS errors (configure API or use proxy)
- ❌ Don't expose sensitive API keys in client-side code
- ❌ Don't assume all APIs return JSON (check Content-Type header)
- ❌ Don't forget to handle network timeouts and offline scenarios
- ❌ Don't make unnecessary API calls (implement caching and debouncing)

### `useSPFxSPHttpClient(initialBaseUrl?)`
**Purpose**: SharePoint REST API client with built-in state management  
**Returns**: `SPFxSPHttpClientInfo`
```typescript
interface SPFxSPHttpClientInfo {
  readonly client: SPHttpClient;                                           // Always available after Provider init
  readonly invoke: <T>(fn: (client: SPHttpClient) => Promise<T>) => Promise<T>;  // Automatic state management
  readonly isLoading: boolean;                                            // Loading state during invoke() calls
  readonly error: Error | undefined;                                      // Last error from invoke() calls
  readonly clearError: () => void;                                        // Clear current error
  readonly setBaseUrl: (url: string) => void;                            // Set/change base URL
  readonly baseUrl: string;                                               // Current base URL (normalized)
}
```

**Parameters:**
- `initialBaseUrl?: string` - Initial base URL (optional, defaults to current site)

**Use Cases**: List operations (CRUD), web/site queries, library operations, search queries, user profile, taxonomy/metadata, cross-site queries, batch operations

**Key Features**:
- Native SPHttpClient with built-in authentication
- Two patterns: invoke() (automatic state) or client (direct access)
- Automatic state management (loading + error) with invoke()
- Cross-site support via setBaseUrl()
- URL normalization (removes trailing slash)
- Lazy service consumption from ServiceScope
- Type-safe with @microsoft/sp-http
- CRUD operations support (GET, POST, MERGE, DELETE)
- Always available (non-undefined) after Provider init
- Error recovery with clearError()

**Implementation Details**:
- Consumes SPHttpClient from ServiceScope with useMemo
- Defaults to PageContext.web.absoluteUrl if no baseUrl provided
- Normalizes baseUrl (removes trailing slash)
- invoke() sets loading, clears error, executes fn, captures errors
- setBaseUrl() normalizes URL before setting state
- Does not track state for direct client usage (only invoke())

**Example - CRUD Operations:**
```typescript
import { SPHttpClient } from '@microsoft/sp-http';

function TasksManager() {
  const { invoke, isLoading, error, clearError, baseUrl } = useSPFxSPHttpClient();
  const [tasks, setTasks] = React.useState([]);
  const [newTaskTitle, setNewTaskTitle] = React.useState('');
  
  React.useEffect(() => { loadTasks(); }, []);
  
  // READ - Fetch tasks
  const loadTasks = () => {
    invoke(client =>
      client.get(
        `${baseUrl}/_api/web/lists/getbytitle('Tasks')/items?$select=Id,Title,Status&$orderby=Created desc`,
        SPHttpClient.configurations.v1
      ).then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        return res.json();
      })
    ).then(data => setTasks(data.value));
  };
  
  // CREATE - Add task
  const createTask = () => {
    if (!newTaskTitle.trim()) return;
    
    invoke(client =>
      client.post(
        `${baseUrl}/_api/web/lists/getbytitle('Tasks')/items`,
        SPHttpClient.configurations.v1,
        {
          headers: {
            'Accept': 'application/json;odata=nometadata',
            'Content-Type': 'application/json;odata=nometadata'
          },
          body: JSON.stringify({ Title: newTaskTitle, Status: 'Not Started' })
        }
      ).then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
    ).then(() => {
      setNewTaskTitle('');
      loadTasks();
    });
  };
  
  // UPDATE - Update task
  const updateTask = (id: number, status: string) => {
    invoke(client =>
      client.post(
        `${baseUrl}/_api/web/lists/getbytitle('Tasks')/items(${id})`,
        SPHttpClient.configurations.v1,
        {
          headers: {
            'IF-MATCH': '*',
            'X-HTTP-Method': 'MERGE',
            'Content-Type': 'application/json;odata=nometadata'
          },
          body: JSON.stringify({ Status: status })
        }
      )
    ).then(() => loadTasks());
  };
  
  // DELETE - Remove task
  const deleteTask = (id: number) => {
    invoke(client =>
      client.post(
        `${baseUrl}/_api/web/lists/getbytitle('Tasks')/items(${id})`,
        SPHttpClient.configurations.v1,
        { headers: { 'IF-MATCH': '*', 'X-HTTP-Method': 'DELETE' } }
      )
    ).then(() => loadTasks());
  };
  
  return (
    <Stack tokens={{ childrenGap: 15 }}>
      {error && (
        <MessageBar 
          messageBarType={MessageBarType.error} 
          onDismiss={clearError}
          actions={<MessageBarButton onClick={() => { clearError(); loadTasks(); }}>Retry</MessageBarButton>}
        >
          {error.message}
        </MessageBar>
      )}
      
      <Stack horizontal tokens={{ childrenGap: 10 }}>
        <TextField
          value={newTaskTitle}
          onChange={(_, val) => setNewTaskTitle(val || '')}
          disabled={isLoading}
        />
        <PrimaryButton text="Add" onClick={createTask} disabled={isLoading} />
      </Stack>
      
      {isLoading && <Spinner />}
      
      <DetailsList
        items={tasks}
        columns={[
          { key: 'id', name: 'ID', fieldName: 'Id', minWidth: 50 },
          { key: 'title', name: 'Title', fieldName: 'Title', minWidth: 200 },
          { key: 'status', name: 'Status', fieldName: 'Status', minWidth: 100 },
          {
            key: 'actions',
            name: 'Actions',
            minWidth: 150,
            onRender: (item) => (
              <Stack horizontal tokens={{ childrenGap: 5 }}>
                <DefaultButton text="Complete" onClick={() => updateTask(item.Id, 'Completed')} />
                <IconButton iconProps={{ iconName: 'Delete' }} onClick={() => deleteTask(item.Id)} />
              </Stack>
            )
          }
        ]}
      />
    </Stack>
  );
}
```

**Best Practices**:
✅ Use invoke() for automatic state management
✅ Check response.ok and throw errors for non-2xx
✅ Use OData query parameters ($select, $filter, $orderby)
✅ Handle errors with clearError() and retry
✅ Use SPHttpClient.configurations.v1
✅ Set proper headers for POST/MERGE/DELETE
✅ Use IF-MATCH: '*' for updates/deletes
✅ Use X-HTTP-Method: 'MERGE' for partial updates
✅ Normalize URLs with baseUrl
✅ Use setBaseUrl() for cross-site queries

❌ Don't forget to check response.ok
❌ Don't ignore error handling
❌ Don't use client if you need state
❌ Don't forget to reload after CRUD
❌ Don't assume all APIs return JSON
❌ Don't make unnecessary API calls
❌ Don't hardcode site URLs
❌ Don't forget IF-MATCH header
❌ Don't use GET for create/update/delete
❌ Don't store SPHttpClient in state

---

#### `useSPFxCrossSitePermissions(siteUrl?, options?)`
**Purpose**: Retrieve permissions for different sites/webs/lists (cross-site permission checks)  
**Returns**: `SPFxCrossSitePermissionsInfo`  
**Use Case**: Cross-site permission validation, multi-site UI, permission delegation, list-level checks

**Description:**  
Fetches and validates permissions across different SharePoint sites, webs, or lists. Implements lazy loading pattern - no fetch occurs until siteUrl is provided. Fetches site, web, and optionally list permissions in parallel for optimal performance.

**Parameters:**
- `siteUrl?: string` - Target site URL (optional - no fetch if undefined/empty)
- `options?: SPFxCrossSitePermissionsOptions`
  - `webUrl?: string` - Specific web URL within the site (e.g., '/sites/mysite/subweb')
  - `listId?: string` - GUID of list to retrieve list-level permissions

**Return Type:**
```typescript
interface SPFxCrossSitePermissionsInfo {
  readonly sitePermissions?: SPPermission;          // Site collection-level permissions
  readonly webPermissions?: SPPermission;           // Web-level permissions
  readonly listPermissions?: SPPermission;          // List-level permissions (if listId provided)
  readonly hasWebPermission: (permission: SPPermission) => boolean;   // Check web permission
  readonly hasSitePermission: (permission: SPPermission) => boolean;  // Check site permission
  readonly hasListPermission: (permission: SPPermission) => boolean;  // Check list permission
  readonly isLoading: boolean;                      // Loading state
  readonly error?: Error;                           // Error state
}
```

**Key Features:**
- Lazy loading - no fetch until URL is set (pass undefined initially)
- Parallel fetching of site/web/list permissions for performance
- Helper methods for permission checks (`hasWebPermission`, etc.)
- Automatic error handling and loading state
- Support for subwebs via `webUrl` option
- List-level permissions via `listId` option
- Uses SPPermission class from @microsoft/sp-page-context

**Example - Lazy loading with permission check:**
```typescript
import { useState } from 'react';
import { SPPermission } from '@microsoft/sp-page-context';

function CrossSitePermissionChecker() {
  const [targetUrl, setTargetUrl] = useState<string | undefined>(undefined);
  
  const { 
    hasWebPermission, 
    hasSitePermission,
    isLoading, 
    error 
  } = useSPFxCrossSitePermissions(targetUrl, {
    webUrl: 'https://contoso.sharepoint.com/sites/target/subweb'
  });
  
  const checkPermissions = () => {
    setTargetUrl('https://contoso.sharepoint.com/sites/target');
  };
  
  if (isLoading) return <Spinner label="Checking permissions..." />;
  if (error) return <MessageBar messageBarType={MessageBarType.error}>{error.message}</MessageBar>;
  
  const canAdd = hasWebPermission(SPPermission.addListItems);
  const canManageSite = hasSitePermission(SPPermission.manageLists);
  
  return (
    <div>
      <button onClick={checkPermissions}>Check Permissions</button>
      {targetUrl && (
        <div>
          <p>Can add items: {canAdd ? '✅' : '❌'}</p>
          <p>Can manage site: {canManageSite ? '✅' : '❌'}</p>
        </div>
      )}
    </div>
  );
}
```

**Best Practices:**
- ✅ Use lazy loading (pass undefined initially) to avoid unnecessary fetches
- ✅ Handle loading and error states for better UX
- ✅ Use helper methods (`hasWebPermission`, etc.) instead of raw SPPermission checks
- ✅ Check permissions at appropriate level (site/web/list) based on operation
- ✅ Cache results when checking multiple permissions on same site
- ✅ Use for conditional UI rendering based on cross-site permissions
- ✅ Include correlation IDs in error logging for troubleshooting
- ❌ Don't fetch permissions unnecessarily (use lazy loading)
- ❌ Don't assume permissions are always available (check undefined)
- ❌ Don't ignore error states (can indicate access issues or network problems)
- ❌ Don't use for current site permissions (use `useSPFxPermissions` instead)
- ❌ Don't poll frequently (permissions don't change often - cache when possible)

#### `useSPFxMSGraphClient()`
**Purpose**: Microsoft Graph API client with built-in state management  
**Returns**: `SPFxMSGraphClientInfo`  
**Use Case**: User profiles, groups, email, calendar, Teams, OneDrive, presence, batch operations

**Description:**  
Provides native MSGraphClientV3 from SPFx for authenticated Microsoft Graph API access. Offers two usage patterns:
1. **invoke()** - Automatic state management (loading + error tracking)
2. **client** - Direct access for full control

Requires MSGraphClientFactory from SPFx ServiceScope (v1.15.0+) and appropriate Microsoft Graph permissions.

**Return Type:**
```typescript
interface SPFxMSGraphClientInfo {
  readonly client: MSGraphClientV3 | undefined;  // Undefined until initialized
  readonly invoke: <T>(fn: (client: MSGraphClientV3) => Promise<T>) => Promise<T>;
  readonly isLoading: boolean;          // Loading state during invoke() calls
  readonly error: Error | undefined;    // Last error from invoke() calls
  readonly clearError: () => void;      // Clear the current error
}
```

**Key Features:**
- Native MSGraphClientV3 with built-in authentication
- Automatic state management with invoke()
- Direct client access for advanced scenarios
- Error handling and retry support
- Lazy initialization via ServiceScope dependency injection
- Type-safe with @microsoft/microsoft-graph-types

**Requirements:**
- SPFx ServiceScope with MSGraphClientFactory service (v1.15.0+)
- Microsoft Graph permissions in `package-solution.json`:
  ```json
  "webApiPermissionRequests": [
    { "resource": "Microsoft Graph", "scope": "User.Read" }
  ]
  ```
- Admin must grant permissions in SharePoint Admin Center → API Management

**Type Safety:**
```bash
npm install @microsoft/microsoft-graph-types --save-dev
```
```typescript
import { MSGraphClientV3 } from '@microsoft/sp-http';
import type * as MicrosoftGraph from '@microsoft/microsoft-graph-types';
```

**Use Cases:**
- **User Profile**: Fetch current user (displayName, mail, jobTitle)
- **Group Management**: List groups, create groups, manage membership
- **Email Operations**: Send emails, read messages, manage mailbox
- **Calendar Integration**: Create events, read calendar, manage availability
- **Teams Operations**: List teams, create channels, post messages
- **OneDrive Access**: Upload files, list drives, manage permissions
- **Presence Information**: Get user presence (online, busy, away)
- **Batch Operations**: Execute multiple Graph API calls in a single request

**Graph API Methods:**
- `.api(path)` - Endpoint (e.g., '/me', '/users', '/groups')
- `.version(v)` - API version ('v1.0' or 'beta')
- `.select(fields)` - Select specific fields
- `.filter(criteria)` - Filter results (OData)
- `.orderBy(field)` - Sort results
- `.top(n)` - Limit results
- `.expand(nav)` - Expand navigation properties
- `.get()`, `.post(data)`, `.patch(data)`, `.put(data)`, `.delete()` - HTTP methods

**Example - User profile with invoke (state management):**
```typescript
import { useSPFxMSGraphClient } from '@apvee/spfx-react-toolkit';
import type * as MicrosoftGraph from '@microsoft/microsoft-graph-types';

function UserProfile() {
  const { invoke, isLoading, error, clearError } = useSPFxMSGraphClient();
  const [user, setUser] = useState<MicrosoftGraph.User | null>(null);
  const [manager, setManager] = useState<MicrosoftGraph.User | null>(null);
  const [photo, setPhoto] = useState<string | null>(null);
  
  const loadUserData = async () => {
    try {
      // Fetch user profile
      const userData = await invoke(client =>
        client.api('/me')
          .select('displayName,mail,jobTitle,department,officeLocation,mobilePhone')
          .get()
      );
      setUser(userData);
      
      // Fetch manager
      const managerData = await invoke(client =>
        client.api('/me/manager')
          .select('displayName,mail,jobTitle')
          .get()
      );
      setManager(managerData);
      
      // Fetch profile photo (returns blob)
      const photoBlob = await invoke(client =>
        client.api('/me/photo/$value').get()
      );
      if (photoBlob) {
        const url = URL.createObjectURL(photoBlob);
        setPhoto(url);
      }
    } catch (err) {
      console.error('Failed to load user data:', err);
    }
  };
  
  useEffect(() => {
    loadUserData();
    // Cleanup photo URL on unmount
    return () => {
      if (photo) URL.revokeObjectURL(photo);
    };
  }, []);
  
  if (isLoading) return <Spinner label="Loading user profile..." />;
  
  if (error) return (
    <MessageBar messageBarType={MessageBarType.error}>
      Error: {error.message}
      <Link onClick={() => { clearError(); loadUserData(); }}>Retry</Link>
    </MessageBar>
  );
  
  if (!user) return null;
  
  return (
    <div style={{ padding: '16px' }}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
        {photo && (
          <img 
            src={photo} 
            alt="Profile" 
            style={{ width: '96px', height: '96px', borderRadius: '50%' }}
          />
        )}
        <div>
          <h2>{user.displayName}</h2>
          <p>{user.jobTitle}</p>
          <p><strong>Email:</strong> {user.mail}</p>
          {user.department && <p><strong>Department:</strong> {user.department}</p>}
          {user.officeLocation && <p><strong>Office:</strong> {user.officeLocation}</p>}
          {user.mobilePhone && <p><strong>Mobile:</strong> {user.mobilePhone}</p>}
        </div>
      </div>
      
      {manager && (
        <div style={{ marginTop: '24px' }}>
          <h3>Manager</h3>
          <p><strong>{manager.displayName}</strong> ({manager.jobTitle})</p>
          <p>{manager.mail}</p>
        </div>
      )}
    </div>
  );
}
```

**Best Practices:**
- ✅ Use invoke() for automatic state management (loading, error)
- ✅ Check `client` for undefined before direct usage
- ✅ Use type-safe imports from @microsoft/microsoft-graph-types
- ✅ Use .select() to request only needed fields (improves performance)
- ✅ Implement error handling with clearError() and retry logic
- ✅ Use .top() to limit results and avoid large payloads
- ✅ Configure minimal required Graph permissions
- ✅ Use batch operations for multiple related API calls
- ✅ Cache Graph API responses when appropriate
- ✅ Clean up blob URLs (URL.revokeObjectURL) when fetching photos
- ✅ Use .version('v1.0') for stable APIs
- ✅ Handle 404 errors gracefully (manager, photo may not exist)
- ❌ Don't call Graph APIs in tight loops or on every render
- ❌ Don't request excessive permissions (principle of least privilege)
- ❌ Don't ignore error states (always show user feedback)
- ❌ Don't use beta APIs in production without fallback
- ❌ Don't fetch large datasets without pagination

#### `useSPFxAadHttpClient(initialResourceUrl?)`
**Purpose**: Access Azure AD-secured APIs with built-in state management  
**Returns**: `SPFxAadHttpClientInfo`  
**Use Case**: Custom APIs secured with Azure AD, third-party integrations, internal business APIs

**Description:**  
Provides native AadHttpClient for authenticated Azure AD-secured API access. Offers two usage patterns:
1. **invoke()** - Automatic state management (loading + error tracking)
2. **client** - Direct access for full control

**Parameters:**
- `initialResourceUrl?: string` - Azure AD resource URL or App ID (optional, can be set later)

**Return Type:**
```typescript
interface SPFxAadHttpClientInfo {
  readonly client: AadHttpClient | undefined;  // Undefined until resourceUrl is set
  readonly invoke: <T>(fn: (client: AadHttpClient) => Promise<T>) => Promise<T>;
  readonly isLoading: boolean;          // Loading state during invoke() calls
  readonly error: Error | undefined;    // Last error from invoke() calls
  readonly clearError: () => void;      // Clear the current error
  readonly setResourceUrl: (url: string) => void;  // Set/change resource URL
  readonly resourceUrl: string | undefined;        // Current Azure AD resource URL
}
```

**Requirements:**
- Add permissions to `package-solution.json` under `webApiPermissionRequests`:
  ```json
  "webApiPermissionRequests": [
    {
      "resource": "api.contoso.com",
      "scope": "user_impersonation"
    }
  ]
  ```
- Admin must grant permissions in SharePoint Admin Center → API Management
- SPFx ServiceScope with AadHttpClientFactory service

**Type Safety:**
```typescript
import { AadHttpClient } from '@microsoft/sp-http';
```

**Example:**
```typescript
import { AadHttpClient } from '@microsoft/sp-http';
import { useState, useEffect } from 'react';
import { MessageBar, MessageBarType, Spinner } from '@fluentui/react';

function OrdersManagerWithCRUD() {
  const { invoke, isLoading, error, clearError, resourceUrl, client } = useSPFxAadHttpClient(
    'https://api.contoso.com'
  );
  const [orders, setOrders] = useState<Order[]>([]);
  
  // Load orders
  const loadOrders = () => {
    invoke(client =>
      client.get(
        `${resourceUrl}/api/orders`,
        AadHttpClient.configurations.v1
      ).then(res => res.json())
    ).then(data => setOrders(data));
  };
  
  // Create order
  const createOrder = (order: any) => {
    invoke(client =>
      client.post(
        `${resourceUrl}/api/orders`,
        AadHttpClient.configurations.v1,
        { body: JSON.stringify(order) }
      ).then(res => res.json())
    ).then(loadOrders);
  };
  
  // Update order
  const updateOrder = (id: string, changes: any) => {
    invoke(client =>
      client.post(
        `${resourceUrl}/api/orders/${id}`,
        AadHttpClient.configurations.v1,
        {
          headers: { 'X-HTTP-Method': 'PATCH' },
          body: JSON.stringify(changes)
        }
      )
    ).then(loadOrders);
  };
  
  // Delete order
  const deleteOrder = (id: string) => {
    invoke(client =>
      client.post(
        `${resourceUrl}/api/orders/${id}`,
        AadHttpClient.configurations.v1,
        { headers: { 'X-HTTP-Method': 'DELETE' } }
      )
    ).then(loadOrders);
  };
  
  useEffect(() => { loadOrders(); }, []);
  
  if (!client) return <Spinner label="Initializing AAD client..." />;
  if (isLoading) return <Spinner label="Loading orders..." />;
  if (error) return (
    <MessageBar messageBarType={MessageBarType.error}>
      {error.message}
      <button onClick={() => { clearError(); loadOrders(); }}>Retry</button>
    </MessageBar>
  );
  
  return (
    <OrdersUI 
      orders={orders} 
      onCreate={createOrder}
      onUpdate={updateOrder}
      onDelete={deleteOrder}
    />
  );
}
```

**Best Practices:**
- ✅ Use `invoke()` for automatic loading/error state management
- ✅ Use `client` directly when you need full control over state
- ✅ Always check if `client` is defined before using it directly
- ✅ Handle errors gracefully with `error` state and `clearError()`
- ✅ Use `resourceUrl` in API calls for dynamic endpoint construction
- ✅ Configure permissions in `package-solution.json` before deployment
- ✅ Test with different API endpoints using `setResourceUrl()`
- ❌ Don't use invoke() if client is undefined (will throw error)
- ❌ Don't forget to handle HTTP error responses (check `response.ok`)
- ❌ Don't hardcode API URLs - use `resourceUrl` from hook

#### `useSPFxOneDriveAppData<T>(fileName, folder?, autoFetch?)`
**Purpose**: Manage JSON files in user's OneDrive appRoot folder with unified read/write operations  
**Returns**: `SPFxOneDriveAppDataResult<T>`  
**Use Case**: User-scoped storage, preferences, cache, per-instance data persistence, form drafts, todo lists

**Description:**  
Provides unified read/write operations for JSON data stored in OneDrive's special appRoot folder (accessible per-app, user-scoped storage). Features automatic JSON serialization/deserialization, separate loading states for read/write operations, folder/namespace support, and memory leak protection.

**Parameters:**
- `fileName: string` - Name of JSON file (e.g., 'config.json', 'settings.json')
- `folder?: string` - Optional folder/namespace for file organization (sanitized to prevent path traversal)
- `autoFetch?: boolean` - Auto-load on mount (default: true)

**Return Type:**
```typescript
interface SPFxOneDriveAppDataResult<T> {
  readonly data: T | undefined;              // Loaded data (undefined if not loaded or error)
  readonly isLoading: boolean;               // Loading state for read operations
  readonly error: Error | undefined;         // Last error from read operations
  readonly isWriting: boolean;               // Loading state for write operations
  readonly writeError: Error | undefined;    // Last error from write operations
  readonly load: () => Promise<void>;        // Manually load/reload the file
  readonly write: (content: T) => Promise<void>;  // Write data (upsert: create or update)
  readonly isReady: boolean;                 // Computed: !isLoading && !error && data !== undefined
}
```

**Key Features:**
- Automatic JSON serialization/deserialization
- Separate loading states for read/write operations
- Optional auto-fetch on mount
- Folder/namespace support for file organization
- Type-safe with TypeScript generics
- Memory leak safe with mounted state tracking
- Error handling for both read and write operations
- Path sanitization (prevents path traversal attacks)
- Upsert behavior (create if doesn't exist, update if exists)

**Requirements:**
- Microsoft Graph permissions: `Files.ReadWrite` or `Files.ReadWrite.AppFolder`
- Configure in `package-solution.json`:
  ```json
  "webApiPermissionRequests": [
    { "resource": "Microsoft Graph", "scope": "Files.ReadWrite" }
  ]
  ```
- Admin must grant permissions in SharePoint Admin Center → API Management

**File Storage Location:**
- Without folder: `/me/drive/special/appRoot:/{fileName}:/content`
- With folder: `/me/drive/special/appRoot:/{folder}/{fileName}:/content`
- Folder names sanitized (only alphanumeric, hyphens, underscores)

**Use Cases:**
- **User Preferences**: Theme, language, UI settings per user
- **Application State**: Persist component state across sessions
- **Cache Storage**: API responses, computed data for offline use
- **Per-Instance Data**: Each WebPart instance has own data (use instanceId as folder)
- **Todo Lists**: CRUD operations for user-specific task lists
- **Form Drafts**: Auto-save form data for later completion

**Example - User preferences with auto-save:**
```typescript
import { useSPFxOneDriveAppData } from '@apvee/spfx-react-toolkit';

interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  language: string;
  notifications: boolean;
  autoSave: boolean;
  fontSize: number;
}

const DEFAULT_PREFERENCES: UserPreferences = {
  theme: 'auto',
  language: 'en',
  notifications: true,
  autoSave: true,
  fontSize: 14
};

function PreferencesPanel() {
  const { 
    data, 
    isLoading, 
    error, 
    write, 
    isWriting, 
    writeError,
    load,
    isReady 
  } = useSPFxOneDriveAppData<UserPreferences>(
    'preferences.json',
    'my-app'  // Store in appRoot:/my-app/preferences.json
  );
  
  // Local state for form inputs
  const [preferences, setPreferences] = useState<UserPreferences>(DEFAULT_PREFERENCES);
  const [hasChanges, setHasChanges] = useState(false);
  
  // Sync loaded data to local state
  useEffect(() => {
    if (data) {
      setPreferences(data);
      setHasChanges(false);
    }
  }, [data]);
  
  // Auto-save when autoSave is enabled and there are changes
  useEffect(() => {
    if (preferences.autoSave && hasChanges && isReady) {
      const timer = setTimeout(async () => {
        try {
          await write(preferences);
          setHasChanges(false);
        } catch (err) {
          console.error('Auto-save failed:', err);
        }
      }, 1000);  // Debounce 1 second
      
      return () => clearTimeout(timer);
    }
  }, [preferences, hasChanges, isReady]);
  
  const handleChange = (field: keyof UserPreferences, value: any) => {
    setPreferences(prev => ({ ...prev, [field]: value }));
    setHasChanges(true);
  };
  
  const handleSave = async () => {
    try {
      await write(preferences);
      setHasChanges(false);
    } catch (err) {
      console.error('Save failed:', err);
    }
  };
  
  const handleReset = () => {
    setPreferences(data ?? DEFAULT_PREFERENCES);
    setHasChanges(false);
  };
  
  if (isLoading) {
    return <Spinner label="Loading preferences..." />;
  }
  
  if (error) {
    return (
      <MessageBar 
        messageBarType={MessageBarType.error}
        actions={<PrimaryButton onClick={load}>Retry</PrimaryButton>}
      >
        Failed to load preferences: {error.message}
      </MessageBar>
    );
  }
  
  return (
    <div style={{ padding: '16px', maxWidth: '600px' }}>
      <h2>User Preferences</h2>
      
      {writeError && (
        <MessageBar messageBarType={MessageBarType.warning}>
          Failed to save: {writeError.message}
        </MessageBar>
      )}
      
      <div style={{ marginTop: '16px' }}>
        <Dropdown
          label="Theme"
          selectedKey={preferences.theme}
          onChange={(_, option) => handleChange('theme', option?.key)}
          options={[
            { key: 'light', text: 'Light' },
            { key: 'dark', text: 'Dark' },
            { key: 'auto', text: 'Auto (System)' }
          ]}
          disabled={isWriting}
        />
      </div>
      
      <div style={{ marginTop: '16px' }}>
        <Dropdown
          label="Language"
          selectedKey={preferences.language}
          onChange={(_, option) => handleChange('language', option?.key)}
          options={[
            { key: 'en', text: 'English' },
            { key: 'it', text: 'Italiano' },
            { key: 'de', text: 'Deutsch' },
            { key: 'fr', text: 'Français' }
          ]}
          disabled={isWriting}
        />
      </div>
      
      <div style={{ marginTop: '16px' }}>
        <Toggle
          label="Enable Notifications"
          checked={preferences.notifications}
          onChange={(_, checked) => handleChange('notifications', checked)}
          disabled={isWriting}
        />
      </div>
      
      <div style={{ marginTop: '16px' }}>
        <Toggle
          label="Auto-Save Changes"
          checked={preferences.autoSave}
          onChange={(_, checked) => handleChange('autoSave', checked)}
          disabled={isWriting}
          onText="Enabled (1s debounce)"
          offText="Disabled"
        />
      </div>
      
      <div style={{ marginTop: '16px' }}>
        <label>Font Size: {preferences.fontSize}px</label>
        <input
          type="range"
          min="12"
          max="20"
          value={preferences.fontSize}
          onChange={(e) => handleChange('fontSize', parseInt(e.target.value))}
          disabled={isWriting}
          style={{ width: '100%', marginTop: '8px' }}
        />
      </div>
      
      <div style={{ marginTop: '24px', display: 'flex', gap: '8px' }}>
        <PrimaryButton
          onClick={handleSave}
          disabled={!hasChanges || isWriting || preferences.autoSave}
        >
          {isWriting ? 'Saving...' : 'Save Changes'}
        </PrimaryButton>
        
        <PrimaryButton
          onClick={handleReset}
          disabled={!hasChanges || isWriting}
        >
          Reset
        </PrimaryButton>
      </div>
      
      {preferences.autoSave && hasChanges && (
        <div style={{ marginTop: '8px', fontSize: '12px', color: '#666' }}>
          Changes will be saved automatically...
        </div>
      )}
    </div>
  );
}
```

**Additional Patterns:**
```typescript
// With folder namespace for isolation
const { data, write } = useSPFxOneDriveAppData<Config>('config.json', 'my-app');

// Per-instance storage (multi-instance support)
const { id } = useSPFxInstanceInfo();
const { data, write } = useSPFxOneDriveAppData<Settings>('settings.json', id);

// Lazy loading (manual load)
const { data, load, isLoading } = useSPFxOneDriveAppData<Cache>(
  'cache.json',
  'my-app',
  false  // Don't auto-fetch
);
```

**Best Practices:**
- ✅ Use folder parameter for namespace isolation (avoid file conflicts)
- ✅ Use instanceId as folder for per-instance storage
- ✅ Implement auto-save with debouncing (avoid excessive writes)
- ✅ Use isReady for conditional rendering
- ✅ Handle both read and write errors separately
- ✅ Provide retry functionality for failed loads
- ✅ Use TypeScript generics for type-safe data access
- ✅ Set autoFetch to false for lazy loading scenarios
- ✅ Use default values when data is undefined
- ✅ Debounce write operations (avoid excessive API calls)
- ✅ Show loading/saving states to user
- ❌ Don't write on every keystroke without debouncing
- ❌ Don't store large files in appRoot (use OneDrive files API)
- ❌ Don't ignore write errors
- ❌ Don't use synchronous operations (all operations are async)
- ❌ Don't store sensitive data without encryption

### `useSPFxTenantProperty<T>(key, autoFetch?)`
**Purpose**: Manage tenant-wide properties using SharePoint StorageEntity API with smart serialization  
**Returns**: `SPFxTenantPropertyResult<T>`
```typescript
interface SPFxTenantPropertyResult<T> {
  readonly data: T | undefined;                                    // Loaded property value
  readonly description: string | undefined;                        // Property description (metadata)
  readonly isLoading: boolean;                                     // Loading state (read operations)
  readonly error: Error | undefined;                               // Read error
  readonly isWriting: boolean;                                     // Loading state (write operations)
  readonly writeError: Error | undefined;                          // Write error
  readonly canWrite: boolean;                                      // Permission check (Site Collection Admin)
  readonly load: () => Promise<void>;                             // Manually load/reload property
  readonly write: (content: T, description?: string) => Promise<void>;  // Write property (CRUD)
  readonly remove: () => Promise<void>;                           // Remove property
  readonly isReady: boolean;                                      // Computed: data loaded successfully
}
```

**Parameters**:
- `key: string` - Unique property key (e.g., 'appVersion', 'apiEndpoint', 'featureFlags')
- `autoFetch?: boolean` - Auto-load on mount. Default: true

**Use Cases**: Tenant-wide configuration, feature flags, API endpoints, version tracking, maintenance mode, max upload sizes, license keys, theme settings

**Key Features**:
- Tenant-wide storage (accessible across all sites)
- Smart serialization (primitives, Date, complex objects)
- Permission checking (canWrite flag)
- Metadata support (description only - SharePoint limitation)
- Type-safe with generics
- Memory leak safe (mounted state tracking)
- Automatic app catalog URL discovery
- Separate error states (read vs write)
- CRUD operations (create, read, update, delete)
- isReady helper for conditional rendering

**Requirements**: 
- Tenant app catalog must be provisioned
- Read: Any authenticated user
- Write/Remove: Site Collection Administrator role on tenant app catalog site
- **Important**: Being a Tenant Admin is NOT sufficient - must be added as Site Collection Admin to app catalog

**Smart Serialization**:
- Primitives (string, number, boolean, null, bigint) → String(content)
- Date objects → toISOString()
- Objects/arrays → JSON.stringify(content)

**Metadata Support**:
- SharePoint StorageEntity only supports `description` field (not `comment`)

**Example - Full CRUD with Permission Handling:**

**Example - Full CRUD with Permission Handling:**
```typescript
interface FeatureFlags {
  enableChat: boolean;
  enableAnalytics: boolean;
  maxUsers: number;
  betaFeatures: string[];
}

function TenantConfigPanel() {
  // String property
  const { 
    data: appVersion, 
    isLoading: versionLoading,
    error: versionError,
    write: writeVersion,
    canWrite: canWriteVersion
  } = useSPFxTenantProperty<string>('appVersion');
  
  // Boolean property
  const { 
    data: maintenanceMode,
    write: setMaintenanceMode,
    canWrite: canWriteMaintenance
  } = useSPFxTenantProperty<boolean>('maintenanceMode');
  
  // Complex object
  const {
    data: featureFlags,
    isLoading: flagsLoading,
    error: flagsError,
    write: writeFlags,
    isWriting: writingFlags,
    writeError: flagsWriteError,
    canWrite: canWriteFlags,
    load: reloadFlags,
    remove: removeFlags
  } = useSPFxTenantProperty<FeatureFlags>('featureFlags');
  
  const [editVersion, setEditVersion] = React.useState('');
  const [editFlags, setEditFlags] = React.useState<FeatureFlags | null>(null);
  
  React.useEffect(() => {
    if (appVersion) setEditVersion(appVersion);
  }, [appVersion]);
  
  React.useEffect(() => {
    if (featureFlags) setEditFlags(featureFlags);
  }, [featureFlags]);
  
  // Version update
  const handleUpdateVersion = async () => {
    if (!canWriteVersion) {
      alert('Insufficient permissions. Must be Site Collection Admin on app catalog.');
      return;
    }
    
    try {
      await writeVersion(editVersion, 'Current application version');
    } catch (err) {
      console.error('Update failed:', err);
    }
  };
  
  // Maintenance toggle
  const toggleMaintenanceMode = async () => {
    if (!canWriteMaintenance) return;
    
    try {
      await setMaintenanceMode(!maintenanceMode, 'Maintenance mode flag');
    } catch (err) {
      console.error('Toggle failed:', err);
    }
  };
  
  // Feature flags update
  const handleUpdateFlags = async () => {
    if (!canWriteFlags || !editFlags) return;
    
    try {
      await writeFlags(editFlags, 'Global feature flags configuration');
    } catch (err) {
      console.error('Update failed:', err);
    }
  };
  
  // Feature flags removal
  const handleRemoveFlags = async () => {
    if (!canWriteFlags || !confirm('Delete? Cannot be undone.')) return;
    
    try {
      await removeFlags();
      setEditFlags(null);
    } catch (err) {
      console.error('Remove failed:', err);
    }
  };
  
  // Maintenance mode banner
  if (maintenanceMode) {
    return (
      <MessageBar messageBarType={MessageBarType.blocked}>
        <strong>System Under Maintenance</strong>
        {canWriteMaintenance && (
          <PrimaryButton onClick={toggleMaintenanceMode}>Disable</PrimaryButton>
        )}
      </MessageBar>
    );
  }
  
  return (
    <Stack tokens={{ childrenGap: 20 }}>
      <Text variant="xxLarge">Tenant Configuration</Text>
      
      {/* Permission warning */}
      {!canWriteVersion && (
        <MessageBar messageBarType={MessageBarType.warning}>
          Read-only access. Must be Site Collection Admin on tenant app catalog.
        </MessageBar>
      )}
      
      {/* Version */}
      <Stack tokens={{ childrenGap: 10 }}>
        <Text variant="xLarge">App Version</Text>
        {versionLoading && <Spinner />}
        {versionError && <MessageBar messageBarType={MessageBarType.error}>{versionError.message}</MessageBar>}
        
        <Stack horizontal tokens={{ childrenGap: 10 }}>
          <TextField
            value={editVersion}
            onChange={(_, val) => setEditVersion(val || '')}
            disabled={!canWriteVersion}
          />
          <PrimaryButton
            text="Update"
            onClick={handleUpdateVersion}
            disabled={!canWriteVersion || editVersion === appVersion}
          />
        </Stack>
      </Stack>
      
      {/* Maintenance */}
      <Stack tokens={{ childrenGap: 10 }}>
        <Text variant="xLarge">Maintenance Mode</Text>
        <Toggle
          checked={maintenanceMode ?? false}
          onChange={toggleMaintenanceMode}
          disabled={!canWriteMaintenance}
        />
      </Stack>
      
      {/* Feature Flags */}
      <Stack tokens={{ childrenGap: 10 }}>
        <Stack horizontal horizontalAlign="space-between">
          <Text variant="xLarge">Feature Flags</Text>
          <Stack horizontal tokens={{ childrenGap: 5 }}>
            <DefaultButton iconProps={{ iconName: 'Refresh' }} onClick={reloadFlags} />
            {canWriteFlags && featureFlags && (
              <DefaultButton iconProps={{ iconName: 'Delete' }} onClick={handleRemoveFlags} />
            )}
          </Stack>
        </Stack>
        
        {flagsLoading && <Spinner />}
        {flagsError && <MessageBar messageBarType={MessageBarType.error}>{flagsError.message}</MessageBar>}
        {flagsWriteError && <MessageBar messageBarType={MessageBarType.error}>{flagsWriteError.message}</MessageBar>}
        
        {editFlags && (
          <Stack tokens={{ childrenGap: 10 }}>
            <Toggle
              label="Enable Chat"
              checked={editFlags.enableChat}
              onChange={(_, checked) => setEditFlags({ ...editFlags, enableChat: checked ?? false })}
              disabled={!canWriteFlags}
            />
            <Toggle
              label="Enable Analytics"
              checked={editFlags.enableAnalytics}
              onChange={(_, checked) => setEditFlags({ ...editFlags, enableAnalytics: checked ?? false })}
              disabled={!canWriteFlags}
            />
            <SpinButton
              label="Max Users"
              value={editFlags.maxUsers.toString()}
              min={1}
              max={10000}
              step={100}
              disabled={!canWriteFlags}
            />
            <PrimaryButton
              text={writingFlags ? 'Saving...' : 'Save'}
              onClick={handleUpdateFlags}
              disabled={!canWriteFlags || writingFlags}
            />
          </Stack>
        )}
      </Stack>
    </Stack>
  );
}
```

**Best Practices**:
✅ Use generic type parameter for type safety
✅ Check canWrite before showing edit UI
✅ Handle both error and writeError separately
✅ Provide meaningful descriptions
✅ Use isReady for conditional rendering
✅ Validate data before using
✅ Use remove() for cleanup
✅ Set autoFetch=false for lazy loading
✅ Display clear permission errors
✅ Use for tenant-wide centralized settings

❌ Don't store sensitive data without encryption
❌ Don't store large datasets
❌ Don't forget write requires Site Collection Admin
❌ Don't assume Tenant Admin is sufficient
❌ Don't write frequently changing data
❌ Don't forget to handle undefined data
❌ Don't ignore errors
❌ Don't use same key for different types
❌ Don't forget app catalog must be provisioned
❌ Don't bypass permission checks

---

### `useSPFxUserPhoto(options?)`
**Purpose**: Load user profile photos from Microsoft Graph API  
**Returns**: `SPFxUserPhotoResult`
```typescript
interface SPFxUserPhotoResult {
  readonly photoUrl: string | undefined;      // Photo URL for <img src={photoUrl} />
  readonly photoBlob: Blob | undefined;       // Raw blob for processing
  readonly isLoading: boolean;                // Loading state
  readonly error: Error | undefined;          // Error state (404, 403, 401)
  readonly reload: () => Promise<void>;      // Manual reload function
  readonly isReady: boolean;                  // Computed: photo loaded successfully
}
```

**Parameters**:
- `options?: SPFxUserPhotoOptions`:
  - `userId?: string` - Microsoft Graph user ID (Azure AD Object ID)
  - `email?: string` - User email/UPN (alternative to userId)
  - `size?: SPFxUserPhotoSize` - Photo size. Default: '240x240'. Available: '48x48', '64x64', '96x96', '120x120', '240x240', '360x360', '432x432', '504x504', '648x648'
  - `autoFetch?: boolean` - Auto-load on mount. Default: true

**Use Cases**: User avatars, profile cards, team member lists, comment sections, people picker, org charts, contact lists, responsive images

**Key Features**:
- Current or specific user by ID/email
- Multiple photo sizes (48x48 to 648x648)
- Automatic blob URL management
- Memory leak prevention (revokes URLs on unmount)
- Type-safe with typed sizes
- Auto-fetch configurable
- Manual reload function
- Enhanced error handling
- Raw blob access for processing
- isReady computed property

**Microsoft Graph Permissions**:
- User.Read (current user)
- User.ReadBasic.All (other users)
- User.Read.All (alternative, more privileged)
- Must be configured in Azure AD
- 404 = no photo (not permission issue)
- 403 = insufficient permissions

**Example:**
```typescript
function UserProfileCard({ userId, email }: { userId?: string; email?: string }) {
  const { photoUrl, isLoading, error, reload, photoBlob } = useSPFxUserPhoto({ 
    userId, 
    email, 
    size: '240x240' 
  });
  
  if (isLoading) return <Spinner label="Loading photo..." />;
  
  if (error) {
    return (
      <Stack>
        <MessageBar messageBarType={MessageBarType.error}>
          Failed: {error.message}
        </MessageBar>
        <DefaultButton onClick={reload} text="Retry" />
      </Stack>
    );
  }
  
  return (
    <Stack tokens={{ childrenGap: 10 }} horizontalAlign="center">
      <img
        src={photoUrl || '/assets/default-avatar.png'}
        alt="User"
        style={{
          width: 240,
          height: 240,
          borderRadius: '50%',
          objectFit: 'cover',
          border: '3px solid #0078d4'
        }}
      />
      <DefaultButton iconProps={{ iconName: 'Refresh' }} onClick={reload} text="Refresh" />
      {photoBlob && <Text variant="small">Size: {(photoBlob.size / 1024).toFixed(2)} KB</Text>}
    </Stack>
  );
}
```

**Best Practices**:
✅ Provide fallback images
✅ Handle loading states with spinners
✅ Handle errors gracefully with retry
✅ Use appropriate sizes for context
✅ Check isReady before displaying
✅ Revoke blob URLs manually if needed
✅ Use small sizes (48-96px) for lists
✅ Use large sizes (240px+) for profiles
✅ Set autoFetch=false for lazy loading
✅ Configure Graph permissions in Azure AD

❌ Don't assume photo always available
❌ Don't forget permission errors (403)
❌ Don't load large photos for small avatars
❌ Don't forget loading states
❌ Don't expose raw errors to users
❌ Don't create multiple instances for same user
❌ Don't forget blob URLs consume memory
❌ Don't use without consent/privacy policies
❌ Don't assume email maps to Graph user
❌ Don't bypass Graph permission requirements

---

## Type Definitions

### Core Types

```typescript
// Provider props
interface SPFxProviderProps<TProps = {}> {
  instance: SPFxComponent<TProps>;
  children?: React.ReactNode;
}

// Component types
type SPFxComponent<TProps = {}> = 
  | BaseClientSideWebPart<TProps>
  | BaseApplicationCustomizer<TProps>
  | BaseListViewCommandSet<TProps>
  | BaseFieldCustomizer<TProps>;

// Host kind
type HostKind = 'WebPart' | 'AppCustomizer' | 'FieldCustomizer' | 'CommandSet' | 'ACE';

// Container size categories
type SPFxContainerSize = 'small' | 'medium' | 'large' | 'xLarge' | 'xxLarge' | 'xxxLarge';

// Container dimensions
interface ContainerSize {
  readonly width: number;
  readonly height: number;
}

// Teams theme
type TeamsTheme = 'default' | 'dark' | 'highContrast';
```

### Hook Return Types

```typescript
// Properties hook
interface SPFxPropertiesInfo<T = unknown> {
  properties: T | undefined;
  setProperties: (props: Partial<T>) => void;
  updateProperties: (updater: (prev: T | undefined) => T) => void;
}

// Display mode hook
interface SPFxDisplayModeInfo {
  mode: DisplayMode | undefined;
  isEdit: boolean;
  isRead: boolean;
}

// User info hook
interface SPFxUserInfo {
  loginName: string;
  displayName: string;
  email?: string;
  isExternal: boolean;
}

// Site info hook
interface SPFxSiteInfo {
  id: string;
  webId: string;
  title: string;
  webUrl: string;
  serverRelativeUrl: string;
  siteClassification?: string;
  group?: SPFxGroupInfo;
  // ... more fields
}

// Permissions hook
interface SPFxPermissionsInfo {
  site: SPPermission | undefined;
  web: SPPermission | undefined;
  list: SPPermission | undefined;
  hasWebPermission: (permission: SPPermission) => boolean;
  hasSitePermission: (permission: SPPermission) => boolean;
  hasListPermission: (permission: SPPermission) => boolean;
}

// Storage hook
interface SPFxStorageHook<T> {
  value: T;
  setValue: (value: T | ((prev: T) => T)) => void;
  remove: () => void;
}

// Performance hook
interface SPFxPerformanceInfo {
  mark: (name: string) => void;
  measure: (name: string, startMark: string, endMark?: string) => SPFxPerfResult;
  time: <T>(name: string, fn: () => Promise<T> | T) => Promise<SPFxPerfResult<T>>;
}

// Logger hook
interface SPFxLoggerInfo {
  debug: (message: string, extra?: Record<string, unknown>) => void;
  info: (message: string, extra?: Record<string, unknown>) => void;
  warn: (message: string, extra?: Record<string, unknown>) => void;
  error: (message: string, extra?: Record<string, unknown>) => void;
}

// OneDrive AppData hook
interface SPFxOneDriveAppDataResult<T> {
  data: T | undefined;
  isLoading: boolean;
  error: Error | undefined;
  isWriting: boolean;
  writeError: Error | undefined;
  load: () => Promise<void>;
  write: (content: T) => Promise<void>;
  isReady: boolean;
}

// Tenant Property hook
interface SPFxTenantPropertyResult<T> {
  data: T | undefined;
  description: string | undefined;  // SharePoint only supports description, not comment
  isLoading: boolean;
  error: Error | undefined;
  isWriting: boolean;
  writeError: Error | undefined;
  canWrite: boolean;
  load: () => Promise<void>;
  write: (content: T, description?: string) => Promise<void>;
  remove: () => Promise<void>;
  isReady: boolean;
}

// User Photo hook
type SPFxUserPhotoSize = '48x48' | '64x64' | '96x96' | '120x120' | '240x240' | '360x360' | '432x432' | '504x504' | '648x648';

interface SPFxUserPhotoOptions {
  userId?: string;        // User Graph ID or Azure AD Object ID
  email?: string;         // User email/UPN
  size?: SPFxUserPhotoSize; // Default: '240x240'
  autoFetch?: boolean;    // Default: true
}

interface SPFxUserPhotoResult {
  photoUrl: string | undefined;     // Blob URL for <img src />
  photoBlob: Blob | undefined;      // Raw blob for processing
  isLoading: boolean;
  error: Error | undefined;
  reload: () => Promise<void>;
  isReady: boolean;
}
```

---

## Common Patterns

### Pattern 1: Property-driven Component

```typescript
interface IMyWebPartProps {
  title: string;
  itemCount: number;
  showHeader: boolean;
}

const MyComponent: React.FC = () => {
  const { properties } = useSPFxProperties<IMyWebPartProps>();
  
  if (!properties) {
    return <Spinner label="Loading..." />;
  }
  
  return (
    <div>
      {properties.showHeader && <h1>{properties.title}</h1>}
      <ItemList count={properties.itemCount} />
    </div>
  );
};
```

### Pattern 2: Responsive Layout

```typescript
const ResponsiveComponent: React.FC = () => {
  const { size, width } = useSPFxContainerSize();
  
  const columns = React.useMemo(() => {
    switch (size) {
      case 'small': return 1;
      case 'medium': return 2;
      case 'large': return 3;
      case 'xLarge': return 4;
      case 'xxLarge': return 5;
      case 'xxxLarge': return 6;
      default: return 3;
    }
  }, [size]);
  
  return <GridLayout columns={columns} />;
};
```

### Pattern 3: Conditional Rendering Based on Permissions

```typescript
const SecureComponent: React.FC = () => {
  const { hasWebPermission } = useSPFxPermissions();
  const canManage = hasWebPermission(SPPermission.manageWeb);
  const canEdit = hasWebPermission(SPPermission.editListItems);
  
  return (
    <div>
      <ContentView />
      {canEdit && <EditButton />}
      {canManage && <AdminPanel />}
    </div>
  );
};
```

### Pattern 4: Data Fetching with Error Handling

```typescript
const DataComponent: React.FC = () => {
  const spHttpClient = useSPFxSPHttpClient();
  const pageContext = useSPFxPageContext();
  const logger = useSPFxLogger();
  const { time } = useSPFxPerformance();
  
  const [data, setData] = React.useState<any[]>([]);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState<string | null>(null);
  
  const fetchData = React.useCallback(async () => {
    if (!spHttpClient) return;
    
    setLoading(true);
    setError(null);
    
    try {
      const result = await time('fetch-lists', async () => {
        const response = await spHttpClient.get(
          `${pageContext.web.absoluteUrl}/_api/web/lists`,
          SPHttpClient.configurations.v1
        );
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const json = await response.json();
        return json.value;
      });
      
      logger.info('Data fetched successfully', {
        itemCount: result.result.length,
        durationMs: result.durationMs
      });
      
      setData(result.result);
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Unknown error';
      logger.error('Failed to fetch data', { error: errorMsg });
      setError(errorMsg);
    } finally {
      setLoading(false);
    }
  }, [spHttpClient, pageContext, logger, time]);
  
  React.useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  if (loading) return <Spinner />;
  if (error) return <MessageBar messageBarType={MessageBarType.error}>{error}</MessageBar>;
  if (!data.length) return <div>No data</div>;
  
  return <DataList items={data} />;
};
```

### Pattern 5: Persistent User Preferences

```typescript
interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  viewMode: 'grid' | 'list' | 'compact';
  itemsPerPage: number;
}

const PreferencesComponent: React.FC = () => {
  const { value: prefs, setValue: setPrefs } = useSPFxLocalStorage<UserPreferences>(
    'user-preferences',
    { theme: 'auto', viewMode: 'grid', itemsPerPage: 10 }
  );
  
  const updateViewMode = (viewMode: UserPreferences['viewMode']) => {
    setPrefs(prev => ({ ...prev, viewMode }));
  };
  
  return (
    <div>
      <ChoiceGroup
        selectedKey={prefs.viewMode}
        options={[
          { key: 'grid', text: 'Grid' },
          { key: 'list', text: 'List' },
          { key: 'compact', text: 'Compact' }
        ]}
        onChange={(_, option) => updateViewMode(option!.key as any)}
      />
      <ContentView mode={prefs.viewMode} itemsPerPage={prefs.itemsPerPage} />
    </div>
  );
};
```

### Pattern 6: Fluent UI 9 Integration

```typescript
import { FluentProvider, Button, Card } from '@fluentui/react-components';

const Fluent9Component: React.FC = () => {
  const { theme, isTeams } = useSPFxFluent9ThemeInfo();
  const { displayName } = useSPFxUserInfo();
  
  return (
    <FluentProvider theme={theme}>
      <Card>
        <h3>Hello from {isTeams ? 'Teams' : 'SharePoint'}!</h3>
        <p>Welcome, {displayName}!</p>
        <Button appearance="primary">Click me</Button>
      </Card>
    </FluentProvider>
  );
};
```

### Pattern 7: Property Pane Sync

```typescript
interface IConfigurableWebPartProps {
  title: string;
  showHeader: boolean;
  maxItems: number;
}

const ConfigurableComponent: React.FC = () => {
  const { properties, setProperties } = useSPFxProperties<IConfigurableWebPartProps>();
  const { isEdit } = useSPFxDisplayMode();
  
  const handleTitleChange = (newTitle: string) => {
    // This will automatically update Property Pane
    setProperties({ title: newTitle });
  };
  
  return (
    <div>
      {isEdit ? (
        <TextField
          value={properties?.title ?? ''}
          onChange={(_, value) => handleTitleChange(value ?? '')}
          placeholder="Enter title..."
        />
      ) : (
        <h1>{properties?.title}</h1>
      )}
    </div>
  );
};
```

### Pattern 8: Teams-Aware Component

```typescript
const TeamsAwareComponent: React.FC = () => {
  const { supported: isTeams, theme: teamsTheme } = useSPFxTeams();
  const { type: envType } = useSPFxEnvironmentInfo();
  
  const environment = React.useMemo(() => {
    if (isTeams) {
      return `Microsoft Teams (${teamsTheme})`;
    }
    return envType === 'SharePoint' ? 'SharePoint Online' : 'Other';
  }, [isTeams, teamsTheme, envType]);
  
  return (
    <div className={isTeams ? 'teams-mode' : 'sharepoint-mode'}>
      <Badge>Running in: {environment}</Badge>
      <Content />
    </div>
  );
};
```

---

## Anti-Patterns (DO NOT USE)

### ❌ Anti-Pattern 1: Accessing context directly

```typescript
// WRONG - Don't access context directly
const MyComponent: React.FC = () => {
  const context = useSPFxContext(); // Too low-level
  const userEmail = context.spfxContext.pageContext.user.email; // Verbose
  
  return <div>{userEmail}</div>;
};

// CORRECT - Use specific hooks
const MyComponent: React.FC = () => {
  const { email } = useSPFxUserInfo();
  
  return <div>{email}</div>;
};
```

### ❌ Anti-Pattern 2: Not handling undefined

```typescript
// WRONG - Properties might be undefined
const MyComponent: React.FC = () => {
  const { properties } = useSPFxProperties<IMyProps>();
  
  return <h1>{properties.title}</h1>; // Runtime error if undefined
};

// CORRECT - Always handle undefined
const MyComponent: React.FC = () => {
  const { properties } = useSPFxProperties<IMyProps>();
  
  return <h1>{properties?.title ?? 'Default Title'}</h1>;
};
```

### ❌ Anti-Pattern 3: Forgetting error handling in HTTP calls

```typescript
// WRONG - No error handling
const fetchData = async () => {
  const spHttpClient = useSPFxSPHttpClient();
  const response = await spHttpClient!.get(url, SPHttpClient.configurations.v1);
  const data = await response.json(); // Might fail
  return data;
};

// CORRECT - Always handle errors
const fetchData = async () => {
  const spHttpClient = useSPFxSPHttpClient();
  
  if (!spHttpClient) {
    throw new Error('SPHttpClient not available');
  }
  
  try {
    const response = await spHttpClient.get(url, SPHttpClient.configurations.v1);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Fetch failed:', error);
    throw error;
  }
};
```

### ❌ Anti-Pattern 4: Using hooks outside SPFxProvider

```typescript
// WRONG - Hook called outside provider
const App: React.FC = () => {
  const { properties } = useSPFxProperties(); // Error!
  
  return <div>{properties?.title}</div>;
};

// In WebPart.render():
ReactDom.render(<App />, this.domElement); // Missing SPFxProvider

// CORRECT - Always wrap with provider
const App: React.FC = () => {
  const { properties } = useSPFxProperties();
  
  return <div>{properties?.title}</div>;
};

// In WebPart.render():
ReactDom.render(
  <SPFxProvider instance={this as never}>
    <App />
  </SPFxProvider>,
  this.domElement
);
```

---

## Migration Guide

### From Vanilla SPFx to Toolkit

#### Before (Vanilla SPFx)

```typescript
// MyWebPart.tsx
import * as React from 'react';
import { WebPartContext } from '@microsoft/sp-webpart-base';

export interface IMyWebPartProps {
  context: WebPartContext;
  title: string;
  description: string;
}

const MyWebPart: React.FC<IMyWebPartProps> = ({ context, title, description }) => {
  const userDisplayName = context.pageContext.user.displayName;
  const siteTitle = context.pageContext.web.title;
  const theme = context.theme;
  
  return (
    <div style={{ backgroundColor: theme.semanticColors.bodyBackground }}>
      <h1>{title}</h1>
      <p>{description}</p>
      <p>User: {userDisplayName}</p>
      <p>Site: {siteTitle}</p>
    </div>
  );
};

// In WebPart render():
const element = React.createElement(MyWebPart, {
  context: this.context,
  title: this.properties.title,
  description: this.properties.description
});
```

#### After (With Toolkit)

```typescript
// MyWebPart.tsx
import * as React from 'react';
import {
  useSPFxProperties,
  useSPFxUserInfo,
  useSPFxSiteInfo,
  useSPFxThemeInfo,
} from '@apvee/spfx-react-toolkit';

interface IMyWebPartProps {
  title: string;
  description: string;
}

const MyWebPart: React.FC = () => {
  const { properties } = useSPFxProperties<IMyWebPartProps>();
  const { displayName } = useSPFxUserInfo();
  const { title: siteTitle } = useSPFxSiteInfo();
  const theme = useSPFxThemeInfo();
  
  return (
    <div style={{ backgroundColor: theme?.semanticColors?.bodyBackground }}>
      <h1>{properties?.title}</h1>
      <p>{properties?.description}</p>
      <p>User: {displayName}</p>
      <p>Site: {siteTitle}</p>
    </div>
  );
};

// In WebPart render():
import { SPFxProvider } from '@apvee/spfx-react-toolkit';

const element = React.createElement(
  SPFxProvider,
  { instance: this as never },
  React.createElement(MyWebPart)
);
```

**Benefits**:
- ✅ No prop drilling
- ✅ Cleaner component API
- ✅ Automatic context propagation
- ✅ Type-safe hooks
- ✅ No manual context passing

---

## Troubleshooting

### Issue 1: "useSPFxContext must be used within SPFxProvider"

**Cause**: Hook called outside `SPFxProvider` wrapper

**Solution**:
```typescript
// ❌ Wrong
ReactDom.render(<MyComponent />, this.domElement);

// ✅ Correct
ReactDom.render(
  <SPFxProvider instance={this as never}>
    <MyComponent />
  </SPFxProvider>,
  this.domElement
);
```

### Issue 2: Properties not updating in Property Pane

**Cause**: Not using `setProperties` from hook

**Solution**:
```typescript
// ❌ Wrong
const { properties } = useSPFxProperties<IMyProps>();
properties.title = 'New'; // Direct mutation

// ✅ Correct
const { properties, setProperties } = useSPFxProperties<IMyProps>();
setProperties({ title: 'New' });
```

### Issue 3: Teams context not available

**Cause**: Teams context loads asynchronously

**Solution**:
```typescript
const { supported, context } = useSPFxTeams();

if (!supported) {
  return <div>Not in Teams</div>;
}

// Now safe to use context
```

### Issue 4: Storage not persisting

**Cause**: Browser privacy settings or incognito mode

**Solution**:
- Check browser allows localStorage/sessionStorage
- Test in normal (non-incognito) window
- Provide fallback for disabled storage

### Issue 5: HTTP client undefined

**Cause**: Accessing client before initialization

**Solution**:
```typescript
const spHttpClient = useSPFxSPHttpClient();

if (!spHttpClient) {
  return <Spinner label="Initializing..." />;
}

// Now safe to use
```

### Issue 6: Container size always 0

**Cause**: Container not yet mounted in DOM

**Solution**:
```typescript
const { width, height } = useSPFxContainerSize();

if (width === 0 || height === 0) {
  return <Spinner />; // Wait for mount
}

// Now safe to use dimensions
```

---

## Additional Resources

### Installation

**Core Package** (includes all standard hooks):
```bash
npm install @apvee/spfx-react-toolkit
```

**Optional PnPjs Integration** (only if using PnP hooks):
```bash
npm install @pnp/sp @pnp/core @pnp/queryable
```

**Note**: Jotai is bundled as a core dependency. PnP packages are optional peer dependencies - install only if you need `useSPFxPnP`, `useSPFxPnPList`, `useSPFxPnPSearch`, or `useSPFxPnPContext`.

---

## PnPjs Hooks

### `useSPFxPnPContext(siteUrl?, config?)`
**Purpose**: Factory hook for creating configured PnPjs SPFI instances with SPFx context, caching, batching, and cross-site support  
**Parameters**: 
- `siteUrl?: string` - SharePoint site URL (undefined: current site, relative: /sites/hr, absolute: https://...)
- `config?: PnPContextConfig` - Optional configuration
  - `cache?: { enabled: boolean, storage?: 'session' | 'local', timeout?: number, keyFactory?: (url: string) => string }`
  - `batch?: { enabled: boolean, maxRequests?: number }`
  - `headers?: Record<string, string>` - Custom HTTP headers

**Returns**: `PnPContextInfo`
```typescript
interface PnPContextInfo {
  readonly sp: SPFI | undefined;           // Configured SPFI instance (undefined if init failed)
  readonly isInitialized: boolean;         // True if successfully initialized
  readonly error: Error | undefined;       // Initialization error details
  readonly siteUrl: string;                // Effective site URL (resolved)
}
```

**Use Cases**: Cross-site dashboards, caching scenarios, custom headers injection, bulk operations with batching, context injection into specialized hooks, current site operations, relative path access, multi-tenant apps

**Key Features**:
- Automatic SPFx context integration with authentication
- URL resolution (absolute/relative/current)
- Optional caching (session/local storage, configurable timeout, default 5min)
- Optional batching for bulk operations (configurable max requests, default 100)
- Custom header injection (Accept-Language, X-Custom, correlation IDs)
- Memoized for performance (no re-initialization on re-renders)
- Detailed error handling with isInitialized flag
- Cross-site operations with separate configs per site
- Selective imports for tree-shaking (only @pnp/sp/webs, @pnp/sp/batching)
- State isolation per context
- Config flexibility (works without memoization, ~0.01-0.05ms overhead if not memoized)

**Implementation Details**:
- Uses spfi() from @pnp/sp to create base instance
- Applies SPFx(spfxContext) for authentication
- Optionally applies Caching() behavior with session/local storage
- Optionally applies InjectHeaders() for custom headers
- URL resolution: undefined → current site, relative → absolute, absolute → as-is
- JSON.stringify for config stability (enables non-memoized configs)
- Error tracking with useState for initialization failures
- Returns undefined sp on error (check isInitialized/error)

**Selective Imports Pattern**:
```typescript
// This hook only imports:
import '@pnp/sp/webs';      // Base web operations
import '@pnp/sp/batching';  // Batching support

// Specialized hooks import their own modules:
// useSPFxPnPList → '@pnp/sp/lists', '@pnp/sp/items'
// useSPFxPnP → user-side selective imports
// This enables optimal tree-shaking
```

**Performance Characteristics**:
```typescript
// JSON.stringify for config stability:
// ✅ Works without memoization (DX priority)
// ⚠️ ~0.01-0.05ms overhead if config not memoized
// ✅ Zero overhead if config memoized/constant

// Overhead negligible vs SPFx operations:
// Network: 100-500ms | React render: 1-5ms | Config stringify: ~0.01-0.05ms

// When to memoize config:
// ✅ Frequent re-renders (100+/sec) or derived from props
// ❌ Static config or rare renders
```

**Example**:
```typescript
import { useSPFxPnPContext } from '@apvee/spfx-react-toolkit';

function MultiSiteDashboard() {
  // Current site (no parameters)
  const currentContext = useSPFxPnPContext();
  
  // Cross-site with caching (inline config - works perfectly)
  const hrContext = useSPFxPnPContext('/sites/hr', {
    cache: {
      enabled: true,
      storage: 'session',
      timeout: 600000  // 10 minutes
    }
  });
  
  // Cross-site with memoized config (optimal for frequent re-renders)
  const financeConfig = useMemo(() => ({
    cache: {
      enabled: true,
      storage: 'local',
      timeout: 300000  // 5 minutes
    },
    headers: {
      'Accept-Language': 'it-IT',
      'X-Department': 'Finance'
    }
  }), []);
  
  const financeContext = useSPFxPnPContext(
    'https://contoso.sharepoint.com/sites/finance',
    financeConfig
  );
  
  // Error handling
  if (currentContext.error) {
    return (
      <MessageBar messageBarType={MessageBarType.error}>
        Current site error: {currentContext.error.message}
      </MessageBar>
    );
  }
  
  if (hrContext.error) {
    if (hrContext.error.message.includes('403')) {
      return <MessageBar>Access denied to HR site</MessageBar>;
    }
    return <MessageBar>HR site error: {hrContext.error.message}</MessageBar>;
  }
  
  if (financeContext.error) {
    return <MessageBar>Finance site error: {financeContext.error.message}</MessageBar>;
  }
  
  // Loading state
  if (!currentContext.isInitialized || !hrContext.isInitialized || !financeContext.isInitialized) {
    return <Spinner label="Initializing connections..." />;
  }
  
  return (
    <Stack tokens={{ childrenGap: 20 }}>
      <Text variant="xxLarge">Multi-Site Dashboard</Text>
      
      {/* Current site section */}
      <section>
        <Text variant="xLarge">Current Site</Text>
        <Text>Connected to: {currentContext.siteUrl}</Text>
        <CurrentSiteWidget context={currentContext} />
      </section>
      
      {/* HR section with caching */}
      <section>
        <Text variant="xLarge">HR Department</Text>
        <Text>Connected to: {hrContext.siteUrl} (cached)</Text>
        <HRWidget context={hrContext} />
      </section>
      
      {/* Finance section with caching + custom headers */}
      <section>
        <Text variant="xLarge">Finance Department</Text>
        <Text>Connected to: {financeContext.siteUrl} (cached, custom headers)</Text>
        <FinanceWidget context={financeContext} />
      </section>
    </Stack>
  );
}

// Usage in child components
function HRWidget({ context }: { context: PnPContextInfo }) {
  // Inject context into useSPFxPnP
  const { invoke, isLoading } = useSPFxPnP(context);
  const [employees, setEmployees] = useState([]);
  
  useEffect(() => {
    if (context.sp) {
      invoke(sp => sp.web.lists.getByTitle('Employees').items.top(10)())
        .then(setEmployees);
    }
  }, [context.sp]);
  
  if (isLoading) return <Shimmer />;
  return <DetailsList items={employees} />;
}
```

**Best Practices**:
✅ Check `isInitialized` before using sp instance
✅ Handle `error` state for user feedback
✅ Use relative paths for tenant-agnostic code
✅ Enable caching for static/frequently accessed data
✅ Reuse context instances across components
✅ Use memoized config for frequent re-renders
✅ Use inline config for static configurations
✅ Handle 403 errors for cross-site operations
✅ Create separate contexts for different sites
✅ Set cache timeout based on data volatility
✅ Inject custom headers for Accept-Language, correlation IDs
✅ Use undefined siteUrl for current site
✅ Validate siteUrl format and handle errors

❌ Don't create new contexts on every render
❌ Don't forget to check `isInitialized`
❌ Don't use absolute URLs when relative works
❌ Don't enable caching for real-time data
❌ Don't ignore error state
❌ Don't assume cross-site permissions
❌ Don't over-memoize static configs
❌ Don't set cache timeout too high for dynamic data
❌ Don't use batching for single operations
❌ Don't hardcode tenant URLs
❌ Don't create contexts in loops/conditionals

---

### `useSPFxPnP(pnpContext?)`
**Purpose**: General-purpose PnPjs wrapper with state management and batching support  
**Parameters**: 
- `pnpContext?: PnPContextInfo` - Optional context from useSPFxPnPContext (default: current site)

**Returns**: `SPFxPnPInfo`
```typescript
interface SPFxPnPInfo {
  readonly sp: SPFI | undefined;                                    // SPFI instance for direct access
  readonly invoke: <T>(fn: (sp: SPFI) => Promise<T>) => Promise<T>; // Single operation with state management
  readonly batch: <T>(fn: (batchedSP: SPFI) => Promise<T>) => Promise<T>; // Batch operations
  readonly isLoading: boolean;                                      // Loading state (invoke/batch only)
  readonly error: Error | undefined;                                // Operation or initialization error
  readonly clearError: () => void;                                  // Clear error state
  readonly isInitialized: boolean;                                  // SP instance ready
  readonly siteUrl: string;                                         // Effective site URL
}
```

**Use Cases**: Single PnP operations, dashboard loading with batch(), cross-site operations, error recovery, advanced scenarios with direct sp access, mixed operations, caching integration

**Key Features**:
- Three usage patterns: invoke() for single ops, batch() for multiple ops, sp for direct access
- Automatic state management for invoke/batch operations
- Batch operations reduce network roundtrips (single HTTP request for multiple operations)
- Selective module imports for tree-shaking and minimal bundle size
- Cross-site support with separate PnPContextInfo instances
- Error handling with clearError() for retry patterns
- Memoized functions, reuses SPFI instance
- Type-safe with generic return types

**Selective Imports Required**:
```typescript
// Import only modules you need (enables tree-shaking)
import '@pnp/sp/lists';        // Lists operations
import '@pnp/sp/items';        // List items
import '@pnp/sp/files';        // Files and folders
import '@pnp/sp/folders';      // Folder operations
import '@pnp/sp/search';       // Search queries
import '@pnp/sp/profiles';     // User profiles
import '@pnp/sp/taxonomy';     // Managed metadata
import '@pnp/sp/site-users';   // Site users
import '@pnp/sp/site-groups';  // Site groups
```

**Implementation Details**:
- invoke(): Executes single operation, tracks loading/error, does not track direct sp usage
- batch(): Creates batched SPFI instance, executes all operations in single HTTP request, auto-executes batch
- isLoading: Shared between invoke/batch, set during operation execution
- error: Prioritizes invoke/batch errors over context initialization errors
- clearError(): Resets error state for retry patterns
- isInitialized: Indicates sp instance readiness
- Direct sp usage: No state tracking - use for advanced scenarios requiring manual control

**State Management**:
- isLoading shared between invoke() and batch()
- error prioritizes operation errors over context errors
- Direct sp usage does NOT update isLoading or error states
- clearError() only clears invoke/batch errors, not context errors

**Performance**:
- invoke() and batch() memoized with useCallback
- Reuses SPFI instance from context (no re-initialization)
- Batching significantly reduces network roundtrips
- Selective imports enable optimal bundle size

**Example**:
```typescript
import '@pnp/sp/lists';
import '@pnp/sp/items';
import { useSPFxPnP } from '@apvee/spfx-react-toolkit';

function DashboardComponent() {
  const { batch, isLoading, error, clearError, isInitialized } = useSPFxPnP();
  const [dashboardData, setDashboardData] = useState(null);
  
  const loadDashboard = async () => {
    try {
      // All operations in ONE HTTP request using batch()
      const [user, tasks, announcements, events] = await batch(async (batchedSP) => {
        const user = batchedSP.web.currentUser();
        const tasks = batchedSP.web.lists
          .getByTitle('Tasks')
          .items
          .select('Id', 'Title', 'Status', 'DueDate')
          .filter("Status eq 'Active'")
          .orderBy('DueDate')
          .top(10)();
        
        const announcements = batchedSP.web.lists
          .getByTitle('Announcements')
          .items
          .top(5)();
        
        const events = batchedSP.web.lists
          .getByTitle('Events')
          .items
          .select('Id', 'Title', 'EventDate', 'Location')
          .filter(`EventDate ge datetime'${new Date().toISOString()}'`)
          .orderBy('EventDate')
          .top(10)();
        
        return Promise.all([user, tasks, announcements, events]);
      });
      
      setDashboardData({ user, tasks, announcements, events });
    } catch (err) {
      console.error('Failed to load dashboard:', err);
      // Error already tracked in state
    }
  };
  
  useEffect(() => {
    if (isInitialized) {
      loadDashboard();
    }
  }, [isInitialized]);
  
  // Handle initialization failure
  if (!isInitialized && error) {
    return (
      <MessageBar messageBarType={MessageBarType.error}>
        Failed to initialize PnP: {error.message}
      </MessageBar>
    );
  }
  
  // Handle loading state
  if (isLoading && !dashboardData) {
    return <Spinner label="Loading dashboard..." />;
  }
  
  // Handle error with retry
  if (error) {
    return (
      <MessageBar
        messageBarType={MessageBarType.error}
        actions={
          <MessageBarButton onClick={() => { clearError(); loadDashboard(); }}>
            Retry
          </MessageBarButton>
        }
      >
        {error.message}
      </MessageBar>
    );
  }
  
  if (!dashboardData) {
    return <div>No data available</div>;
  }
  
  return (
    <Stack tokens={{ childrenGap: 20 }}>
      <Text variant="xLarge">Welcome, {dashboardData.user?.Title}</Text>
      
      <section>
        <Text variant="large">My Tasks ({dashboardData.tasks.length})</Text>
        {isLoading && <Shimmer />}
        <DetailsList
          items={dashboardData.tasks}
          columns={[
            { key: 'Title', name: 'Title', fieldName: 'Title', minWidth: 200 },
            { key: 'Status', name: 'Status', fieldName: 'Status', minWidth: 100 },
            { key: 'DueDate', name: 'Due Date', fieldName: 'DueDate', minWidth: 120 }
          ]}
        />
      </section>
      
      <section>
        <Text variant="large">Recent Announcements</Text>
        <List items={dashboardData.announcements} />
      </section>
      
      <section>
        <Text variant="large">Upcoming Events</Text>
        <List items={dashboardData.events} />
      </section>
      
      <DefaultButton onClick={loadDashboard} disabled={isLoading}>
        {isLoading ? 'Refreshing...' : 'Refresh Dashboard'}
      </DefaultButton>
    </Stack>
  );
}
```

**Best Practices**:
✅ Use batch() to load multiple resources (reduces network roundtrips)
✅ Check isInitialized before making PnP operations
✅ Import only PnP modules you use (tree-shaking)
✅ Use invoke() for single operations, batch() for multiple
✅ Implement error handling with clearError() for retry patterns
✅ Distinguish initialization errors from operation errors
✅ Show different loading states (initial vs refresh)
✅ Pass PnPContextInfo for cross-site operations
✅ Reuse PnPContextInfo instances across components
✅ Use direct sp only for advanced manual control
✅ Handle undefined sp gracefully
✅ Combine related operations in single batch() call
✅ Use Promise.all() within batch callback

❌ Don't rely on isLoading/error for direct sp usage
❌ Don't import all PnP modules
❌ Don't make sequential invoke() calls when batch() works
❌ Don't forget to check undefined sp before direct usage
❌ Don't create new PnPContextInfo unnecessarily
❌ Don't ignore initialization errors
❌ Don't use batch() for single operations
❌ Don't nest batch() calls
❌ Don't forget error handling in operations
❌ Don't assume permissions are available
❌ Don't perform heavy operations on every render

---

### `useSPFxPnPList<T>(listTitle, options?, pnpContext?)`
**Purpose**: Specialized hook for SharePoint list operations with native PnPjs fluent API, CRUD, batch operations, pagination  
**Parameters**: 
- `listTitle: string` - SharePoint list title (required)
- `options?: UseSPFxPnPListOptions` - `pageSize?: number` for pagination
- `pnpContext?: PnPContextInfo` - Optional for cross-site (default: current site)

**Returns**: `SPFxPnPListInfo<T>` with 17 properties/methods (query, items, loading, loadingMore, error, isEmpty, hasMore, refetch, loadMore, clearError, getById, create, update, remove, createBatch, updateBatch, removeBatch)

**Use Cases**: List queries, pagination, CRUD forms, batch operations, cross-site dashboards, type-safe filters, real-time lists

**Key Features**: Native PnPjs fluent API, smart .top() detection (Proxy), CRUD with auto-refetch (100ms debounce), batch operations, pagination, local state per instance, cross-site, ES5 compatible, TypeScript, error handling

**Smart .top() Detection**: User .top() → use it | No .top() + pageSize → add .top(pageSize) | Neither → no limit | Both → .top() wins + warning

**Example**: See comprehensive example in full documentation with query, CRUD, pagination, error handling

**Best Practices**:
✅ Import '@pnp/sp/lists', '@pnp/sp/items' | Use type parameter | Use pageSize | Check isEmpty | Handle errors | Use batch for bulk | Filter indexed columns for >5000 items | Use fluent filter API
❌ Don't specify both .top() and pageSize | Don't query >5000 without indexed filters | Don't call refetch() after CRUD | Don't use pageSize >5000 | Don't fetch all fields

---

### `useSPFxPnPSearch<T>(options?, pnpContext?)`
**Purpose**: SharePoint Search API with SearchQueryBuilder, suggestions, refiners, pagination, verticals  
**Parameters**: 
- `options?: UseSPFxPnPSearchOptions` - `pageSize?: number` (default: 50), `selectProperties?: string[]`, `refiners?: string`
- `pnpContext?: PnPContextInfo` - Optional for cross-site (default: current site)

**Returns**: `SPFxPnPSearchInfo<T>` with 13 properties/methods (search, suggest, results, totalResults, refiners, loading, loadingMore, hasMore, error, loadMore, refetch, applyRefiner, clearError)

**Use Cases**: Document search, people search, site search, autocomplete, faceted search, cross-site discovery, advanced queries, pagination

**Key Features**: Native PnPjs SearchQueryBuilder, auto-parsing Cells to objects, search suggestions (autocomplete), refiners (facets), pagination, SearchVerticals constants (People/Videos/Sites/Documents/Conversations/Pages), cross-site, local state, ES5 compatible, TypeScript, flexible queries (text or builder)

**SearchResult Type**:
```typescript
interface SearchResult<T> {
  id: string;              // From Path or DocId
  data: T;                 // Parsed typed object
  raw: unknown;            // Raw ISearchResult
  rank?: number;           // Relevance score
}
interface SearchRefiner {
  name: string;
  entries: Array<{ value: string; count: number; token: string; }>;
}
```

**Implementation Details**: Uses PnPjs SearchQueryBuilder, auto-parses ISearchResult to SearchResult<T>, search() accepts text or builder function with default options applied before user callback, suggest() returns string array for autocomplete, refiners parsed from RawSearchResults, applyRefiner() toggles refiner value and calls refetch(), loadMore() increments startRow and appends results, state includes appliedRefiners Map for refinement filters

**SearchVerticals**: All (undefined), People, Videos, Sites, Documents, Conversations, Pages (use constants: `SearchVerticals.People`, etc.)

**Example**: See comprehensive example in full documentation with search, refiners, pagination, error handling

**Best Practices**:
✅ Import '@pnp/sp/search' | Use type parameter | Specify selectProperties | Use SearchVerticals | Implement pagination | Use suggest() for autocomplete | Request refiners | Handle errors | Use applyRefiner() | Use sortList() | Pass PnPContextInfo for cross-site | Limit refiner entries
❌ Don't forget '@pnp/sp/search' | Don't request all properties | Don't set pageSize >500 | Don't ignore errors | Don't call search() on every keystroke | Don't assume refiners available | Don't create hooks in loops | Don't ignore totalResults | Don't use vertical IDs directly

---

### Links

- **GitHub**: https://github.com/apvee/spfx-react-toolkit
- **Issues**: https://github.com/apvee/spfx-react-toolkit/issues
- **SPFx Docs**: https://learn.microsoft.com/sharepoint/dev/spfx/
- **Jotai Docs**: https://jotai.org/
- **Fluent UI**: https://react.fluentui.dev/
- **Microsoft Graph**: https://learn.microsoft.com/graph/
- **PnPjs Docs**: https://pnp.github.io/pnpjs/

---

## Version History

- **0.0.1** (Initial): Core hooks, provider, TypeScript support
- Compatible with SPFx >=1.18.0
- React 17.x
- Node.js version aligned with your SPFx version (e.g., Node 18.x for SPFx 1.21.1 - see [SPFx compatibility table](https://learn.microsoft.com/sharepoint/dev/spfx/compatibility))

---

**End of LLM Reference Guide**
